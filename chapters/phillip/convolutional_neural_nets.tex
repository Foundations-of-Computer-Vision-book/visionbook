%\setcounter{chapter}{23}
\chapter{Convolutional Neural Nets}
\label{chapter:convolutional_neural_nets}

\section{Introduction}

The neural nets we saw in \chap{\ref{chapter:neural_nets}} are designed to process generic data. But in many domains the data has special structure, and we can design neural net architectures that are better suited to exploiting that structure. \index{Convolutional neural nets}{\bf Convolutional neural nets}, also called {\bf convnets} or {\bf CNNs}, are a neural net architecture especially suited to the structure in visual signals.


%CNNs take their name from the fact they are composed of {\bf convolutional layers}, which are layers that apply a convolutional filter to their input.

The key idea of CNNs is to chop up the input image into little patches, and then process each patch \textit{independently} and \textit{identically}. The gist of this is captured in \fig{\ref{fig:convolutional_neural_nets:CNNs_as_patch_processing}}:
\vspace{-0.2cm}
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.95\linewidth]{./figures/convolutional_neural_nets/CNNs_as_patch_processing.pdf}}
    \caption{CNNs as patch processing. {\em Photo source}: Fredo Durand.}
    \label{fig:convolutional_neural_nets:CNNs_as_patch_processing}
\end{figure}
\vspace{-0.2cm}

\marginnote{CNNs are also well suited to processing many other spatial or temporal signals, such as geospatial data or sounds. If there is a natural way to scan across a signal, processing each windowed region separately, then CNNs may be a reasonable choice.}[-2.5cm]
Each patch is processed with a classifier module, which is a neural net. Essentially, this neural net scans across the patches in the input and classifies each. The output is a label \textit{for each patch in the input image}. If we rearrange these predictions back into the shape of the input image and color code them, we get the below input-output mapping (\fig{\ref{fig:convolutional_neural_nets:CNN_example_coarse}}):
\vspace{-0.2cm}
\begin{figure}[h!]
    \centerline{
        \includegraphics[width=0.95\linewidth]{./figures/convolutional_neural_nets/CNN_example_coarse.pdf}}
    \caption{Input-output mapping of a CNN.}
    \label{fig:convolutional_neural_nets:CNN_example_coarse}
\end{figure}

Notice that this is quite different than the neural nets we saw in \chap{\ref{chapter:neural_nets}}, which output a single prediction an the entire image; CNNs output a two-dimensional (2D) \textit{array} of predictions.

We may also chop up the image into \textit{overlapping} patches. If we do this densely, such that each patch is one pixel offset from the last, we get a full resolution image of predictions (\fig{\ref{fig:convolutional_neural_nets:CNN_example_fine}}):
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.95\linewidth]{./figures/convolutional_neural_nets/CNN_example_fine.pdf}}
    \caption{Dense input-output mapping.}
    \label{fig:convolutional_neural_nets:CNN_example_fine}
\end{figure}
\vspace{-0.2cm}

%\newpage
Now that looks impressive! This CNN solved a task known as \index{semantic segmentation}\textbf{semantic segmentation}, which is the task of assigning a class label to each pixel in an image. One reason CNNs are powerful is because they map an input image to an output image \textit{with the same shape}, rather than outputting a single label like in the nets we saw in previous chapters. CNNs can also be generalized to input and output other kinds of structures. The key property is that the output matches the topology of the input: an N-dimensional (ND) tensor of inputs will be mapped to an  ND tensor of outputs.%, except possibly downsampled or upsampled. A special case is when we downsample so much that the output is a single value. This case is used when we want to run CNNs as an image classifier that just outputs a single label for the whole image.

Keeping in mind that chopping up and predicting is really all a CNN is doing, we will now dive into the details of how they work.

\section{Convolutional Layers}
CNNs are neural networks that are composed of \index{Convolutional layer}{\bf convolutional layers}. A convolutional layer transforms inputs $\xin$ to outputs $\xout$ by convolving $\xin$ with one or more filters $\mathbf{w}$. A convolutional layer with a single filter looks like this:
\begin{align}
    \xout = \mathbf{w} \star \xin + b & \quad\quad \triangleleft \quad \texttt{conv}\label{eqn:convolutional_neural_nets:convolutional_filter}
\end{align}
where $\mathbf{w}$ is the kernel and $b$ is the bias; $\theta = [\mathbf{w}, b]$ are the parameters of this layer.
\marginnote{In this chapter, we deviate slightly from our usual notation and use lowercase for convolutional filter $\mathbf{w}$, regardless of whether the kernel is a 1D array, a 2D array, or an ND array.}[-5.4cm]

Recalling the definition of the operator $\star$ from \chap{\ref{chapter:linear_image_filtering}}, we give here an example of a convolutional layer over a 2D array $\xin$, using a square kernel of size $K \times K$:
\begin{align}
    \xoutnonbold[n,m] =
    b + \sum_{k_1,k_2=-K}^K w[k_1,k_2] \xinnonbold[n+k_1,m+k_2] & \quad\quad \triangleleft \quad \texttt{conv}\quad \text{(expanded)}\label{eqn:convolutional_neural_nets:convolutional_filter_expanded}
\end{align}
\marginnote{``Convolutional'' layers in deep nets are typically actually defined as cross-correlations ($\star$) and we stick to that convention in this book. We need not worry about the misnomer because whether you implement the layers with convolution or cross-correlation usually makes no difference for learning. This is because both \textit{span an identical hypothesis space} (any cross-correlation can be converted to an equivalent convolution by flipping the filter horizontally and vertically).}[-3cm]

As discussed in \chap{\ref{chapter:linear_image_filtering}}, convolution is just a special kind of linear transform. Similarly, a convolutional layer is just a special kind of linear layer. It is a linear layer whose matrix $\mathbf{W}$ is Toeplitz. We can view it either as a matrix or as a neural net, as shown in \fig{\ref{fig:convolutional_neural_nets:conv_matrix_vs_net}}, which shows the case of a one-dimensional (1D) convolution over a 1D signal $\xin$, with zero bias.
% \begin{figure}[h]
% \centerline{
%     \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/conv_matrix_vs_net.pdf}}
%     \label{fig:convolutional_neural_nets:conv_matrix_vs_net}
%     \caption{A convolutional layer.}
% \end{figure}
\begin{figure}[h!]
    \begin{minipage}{0.45\linewidth}
        \centering
        \begin{tikzpicture}
            %
            \def\Nnodes{9}
            \def\cellwidth{0.3}
            % draw xin
            \foreach \y in {1,...,\Nnodes} {
                    \draw [fill=data_color] (\cellwidth,-\cellwidth*\y-0.5*\cellwidth) rectangle ++(\cellwidth,\cellwidth);
                }
            %
            \draw (\cellwidth*3,-\cellwidth) node {$=$};
            % draw W
            \foreach \x in {1,...,\Nnodes} {
                    \foreach \y in {1,...,\Nnodes} {
                            \pgfmathtruncatemacro\yminusone{\y-1}
                            \pgfmathtruncatemacro\yplusone{\y+1}
                            \ifthenelse{\x=\y \OR \x=\yminusone \OR \x=\yplusone}{
                                \draw [shift={(\cellwidth*3,0)}, fill=param_color] (\cellwidth*\x,-\cellwidth*\y-0.5*\cellwidth) rectangle ++(\cellwidth,\cellwidth);
                            }
                            {
                                \draw [shift={(\cellwidth*3,0)}, fill=white] (\cellwidth*\x,-\cellwidth*\y-0.5*\cellwidth) rectangle ++(\cellwidth,\cellwidth);
                            }
                        }
                }
            % draw lines indicating shared weights
            \foreach \k in {-1,...,1} {
                    \pgfmathtruncatemacro\negk{-\k}
                    \ifthenelse{\k=-1} {
                        \pgfmathtruncatemacro\offtop{1}
                    }
                    {
                        \pgfmathtruncatemacro\offtop{0}
                    }
                    \ifthenelse{\k=1} {
                        \pgfmathtruncatemacro\offbot{1}
                    }
                    {
                        \pgfmathtruncatemacro\offbot{0}
                    }
                    \draw [shift={(\cellwidth*3,0)}, thick, dashed] (\cellwidth*1.5+\k*\cellwidth+\offtop*\cellwidth,-\cellwidth-\offtop*\cellwidth) -- (\cellwidth*\Nnodes+0.5*\cellwidth+\k*\cellwidth-\offbot*\cellwidth,-\cellwidth*\Nnodes+\offbot*\cellwidth);
                    \path[shift={(\cellwidth*3+\k*1.1*\cellwidth,-\k*0.25*\cellwidth)}] (\cellwidth*1.5+\offtop*\cellwidth,-\cellwidth+\k*\cellwidth-\offtop*\cellwidth) -- node[scale=0.65, fill=param_color, draw=black, thick, text centered, minimum width=1cm] {$w[\negk]$} (\cellwidth*\Nnodes+0.5*\cellwidth-\offbot*\cellwidth,-\cellwidth*\Nnodes+\k*\cellwidth+\offbot*\cellwidth);
                }
            % draw xout
            \foreach \y in {1,...,\Nnodes} {
                    \draw [shift={(\cellwidth*\Nnodes+\cellwidth*3.5,0)}, fill=data_color] (\cellwidth,-\cellwidth*\y-0.5*\cellwidth) rectangle ++(\cellwidth,\cellwidth);
                }
            %
            \draw (\cellwidth*1.5,-\cellwidth*\Nnodes-1.5*\cellwidth) node {$\xout$};
            \draw [shift={(\cellwidth*\Nnodes+\cellwidth*3.5,0)}] (\cellwidth*1.5,-\cellwidth*\Nnodes-1.5*\cellwidth) node {$\xin$};
            %
        \end{tikzpicture}
    \end{minipage}
    \begin{minipage}{0.08\linewidth}
        \centering
        \begin{tikzpicture}
            \def\cellwidth{0.25}
            \def\Nnodes{9}
            \draw (0,-\cellwidth*0.5*\Nnodes) node {$\Longleftrightarrow$};
        \end{tikzpicture}
    \end{minipage}
    \begin{minipage}{0.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{scope}[rotate=-90]
                %
                \def\Nnodes{9}
                \def\Nlayers{2}
                \def\layerheight{2.6}
                \def\neuronrad{0.14}
                \def\neuronstep{0.42}
                % draw all nodes
                \foreach \y in {1,...,\Nlayers} {
                        \foreach \x in {1,...,\Nnodes} {
                                \draw [fill=data_color] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                            }
                    }
                % draw nodes in RF
                % \node [circle, draw, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${\mathbf{x}_1[3]}$] (myNode) at (\neuronstep*4,\layerheight) {};
                %
                % draw all edges
                \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                \foreach \y in {1,...,\NlayersMinusOne} {
                        \foreach \x in {1,...,\Nnodes} {
                                \foreach \k in {-1,...,1} {
                                        \pgfmathtruncatemacro{\xk}{\x+\k}
                                        \ifnum \xk>0
                                            \ifnum \xk<\NNodesPlusOne
                                                \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                            \fi
                                        \fi
                                    }
                            }
                    }
                % draw edges in RF
                \foreach \k in {-1,...,1} {
                        \pgfmathtruncatemacro{\negk}{-\k}
                        \pgfmathtruncatemacro{\xk}{2+\k}
                        \draw [thick] [nn_edge] (\neuronstep*\xk,\neuronrad) -- (\neuronstep*2,\layerheight-\neuronrad);
                        \path[shift={(\k*0.25,-\layerheight*0.2)}] (\neuronstep*\xk,\neuronrad) -- node[scale=0.65, fill=param_color, draw=black, thick, text centered, minimum width=1cm] {$w[\negk]$} (\neuronstep*2,\layerheight-\neuronrad);
                    }
                \foreach \k in {-1,...,1} {
                        \pgfmathtruncatemacro{\negk}{-\k}
                        \pgfmathtruncatemacro{\xk}{6+\k}
                        \draw [thick] [nn_edge] (\neuronstep*\xk,\neuronrad) -- (\neuronstep*6,\layerheight-\neuronrad);
                        \path[shift={(\k*0.25,-\layerheight*0.2)}] (\neuronstep*\xk,\neuronrad) -- node[scale=0.65, fill=param_color, draw=black, thick, text centered, minimum width=1cm] {$w[\negk]$} (\neuronstep*6,\layerheight-\neuronrad);
                    }
                %
                \draw (\neuronstep*\Nnodes+\neuronstep,0) node {$\xin$};
                \draw (\neuronstep*\Nnodes+\neuronstep,\layerheight) node {$\xout$};
            \end{scope}
        \end{tikzpicture}
    \end{minipage}
    \caption{Two equivalent visualizations of a convolutional layer.}
    \label{fig:convolutional_neural_nets:conv_matrix_vs_net}
\end{figure}

We already saw that convolutional filters are useful for image processing in \partsref \ref{part:image_processing} and \ref{part:linear_filters}. In those parts, we introduced a variety of hand-designed filter banks with useful properties. A CNN instead \textit{learns} an effective filter bank.


\subsection{Multi-Input, Multi-Output Convolutional Layers}
In image processing, convolution usually refers to filtering a 1-channel signal and producing a 1-channel output, e.g., filtering a grayscale image and producing a scalar-valued response image. In neural networks, convolutional layers are more general, and typically map a multichannel input to a multichannel output. In this section we define how to handle multichannel inputs, then how to handle multichannel outputs, and then put them together to define the fully general convolutional layer.

\paragraph*{Multichannel inputs}

Suppose we have an RGB image $\xin \in \mathbb{R}^{3 \times N \times M}$. To apply a convolutional layer to such a multichannel image we simply use a multichannel filter $\mathbf{w} \in \mathbb{R}^{C \times K \times K}$, and filter each input channel with the corresponding filter channel, then sum the responses:
\begin{align}
    \xout = \sum_{c} \mathbf{w}[c,:,:] \star \xin[c,:,:] + b[c] & \quad \triangleleft \quad\texttt{conv}\quad \text{(multichannel in)}
\end{align}

\paragraph*{Multichannel outputs}
Above we saw a convolutional layer with just a single filter. More commonly each convolutional layer in a neural network will apply a set of filters, i.e. a \index{Filter bank}\textbf{filter bank}.\marginnote{We introduced filter banks in \chap{\ref{chapter:filter_banks}}. The difference here is that in CNNs the filter weights are learned.}[-0.4cm] If we have a bank of $C$ filters $\mathbf{w}_0, \ldots, \mathbf{w}_{C-1}$, and apply them to a grayscale input image $\xin \in \mathbb{R}^{N \times M}$, we get $C$ output images:
\begin{align}
    \xout[0,:,:] & = \mathbf{w}[0,:,:] \star \xin + b[0]     \\
                 & \vdots \nonumber                          \\
    \xout[C,:,:] & = \mathbf{w}[C-1,:,:] \star \xin + b[C-1]
    \label{eqn:convolutional_neural_nets:convolutional_layer_filter_bank}
\end{align}
Now $\xout$ is an image with $C$ channels. Each channel is the response of the input image to one of the filters.\marginnote{We use the term ``image'' to refer to any 2D array of measurements or features. An image does not have to be a conventional photograph.}[-0.4cm] We call each of these channels a \index{Feature map}\textbf{feature map}, as it shows some features of the input, such as where the vertical edges are.

\paragraph*{Multi-Input, Multi-Output} Putting both of the above together, we can define a general convolutional layer that maps a signal with $\Cin$ input channels to a signal with $\Cout$ output channels. Here is what this looks like for an image $\xin \in \mathbb{R}^{\Cin \times N \times M}$, where $c_2$ indexes the output channel, with $c_2 \in \{0, \ldots, \Cout-1\}$:
\begin{align}
    \xout[\cout,:,:] = \sum_{\cin=1}^{\Cin} \mathbf{w}[\cin,\cout,:,:] \star \xin[\cin,:,:] + b[\cout] & \quad \triangleleft \quad\texttt{conv}\quad \text{(multi-in-out)}
    \label{eqn:convolutional_neural_nets:convolutional_layer_multichannel}
\end{align}
%$\mathbf{x}_{\texttt{out}}[c,:,:]$ is the $c$-th channel of the output, also called the $c$-th {\bf feature map}.\marginnote{We introduced filter banks in \chap{\ref{chapter:filter_banks}}. The difference here is that in CNNs the filter weights are learned.}[-0.4cm] 
Notation for multichannel convolutions can get hard to keep track of, so let's spell out a few of the pieces here, which are also visualized in \fig{\ref{fig:convolutional_neural_networks:multichannel_conv}}:
\begin{itemize}
    \item $\mathbf{x}_{\texttt{in}}[\cin,:,:]$ is the $\cin$-th channel of the input signal.
    \item The filter bank is $\Cout$ filters, $[\mathbf{w}[:,0,:,:], \ldots, \mathbf{w}[:,\Cout-1,:,:]]$, each of which applies one convolutional filter per input channel and then sums the responses over all these filters.
    \item This convolutional layer maps inputs $\xin \in \mathbb{R}^{\Cin \times N \times M}$ to outputs $\xout \in \mathbb{R}^{\Cout \times N \times M}$.
    \item  The filter bank is represented by a tensor $\mathbf{w} \in \mathbb{R}^{\Cin \times \Cout \times K \times K}$, where $K$ is the (spatial, square) kernel size.
\end{itemize}

%For images, the input signal is a $\Cin \times N \times M$ tensor of pixels, where $H$ is the image height, $W$ is the image width, and $\Cin$ is the number of color channels (usually 3), and the output signal is an $\Cout \times H \times W$ tensor of features (neural activations).

\begin{figure}[t]
    \centerline{
        \begin{tikzpicture}
            \def\H{7}
            \def\W{7}
            \def\NchannelsIn{3}
            \def\NchannelsOut{2}
            \def\K{3}
            \def\cellwidth{0.25}

            % draw filter bank
            \foreach \f in {1,...,\NchannelsOut} {
                    \foreach \c in {1,...,\NchannelsIn} {
                            \foreach \x in {1,...,\K} {
                                    \foreach \y in {1,...,\K} {
                                            \draw [shift={(\c*\cellwidth*0.5, -\c*\cellwidth*0.5 - \f*\cellwidth*1.5*\K + \cellwidth*1.5*\K)}, fill=param_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                                        }
                                }
                        }
                }
            % draw K below
            \draw[shift={(\NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5 - \NchannelsOut*\cellwidth*1.5*\K*0.5 + \cellwidth*1.5*\K*0.5)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*\K+\cellwidth,-\cellwidth*\K-2.5*\cellwidth) -- (\cellwidth*1,-\cellwidth*\K-2.5*\cellwidth);
            \node[shift={(\NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5 - \NchannelsOut*\cellwidth*1.5*\K*0.5 + \cellwidth*1.5*\K*0.5)}, below, rotate=0] at (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K-3*\cellwidth) {$\small{K}$};
            % draw K right
            \draw[shift={(\NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5 - \NchannelsOut*\cellwidth*1.5*\K*0.5 + \cellwidth*1.5*\K*0.5)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*\K+\cellwidth*1.25,-\cellwidth*2.25) -- (\cellwidth*\K+\cellwidth*1.25,-\cellwidth*\K-2.25*\cellwidth);
            \node[shift={(\NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5 - \NchannelsOut*\cellwidth*1.5*\K*0.5 + \cellwidth*1.5*\K*0.5)}, right, rotate=0] at (\cellwidth*\K+1.75*\cellwidth,-\cellwidth*\K*0.5-2.25*\cellwidth) {$\small{K}$};
            % draw number of Cin and Cout
            \draw[decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth,-\cellwidth*1.5*\K*\NchannelsOut) -- (\cellwidth,-\cellwidth*0.5);
            \node[left, rotate=90] at (-\cellwidth*0.75,-\cellwidth*1.5*\K*\NchannelsOut*0.5+\cellwidth*1.5*\NchannelsOut*1) {$\small{\Cout \text{ filters}}$};
            %
            \draw[shift={(\cellwidth*\K+2*\cellwidth, 0)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (0,0) -- (\cellwidth,-\cellwidth*2);
            \node[shift={(\cellwidth*\K+2*\cellwidth, 0)}, right, rotate=0] at (\cellwidth*0.5,0) {$\small{\Cin}$};
            \draw[shift={(2 + \W*\cellwidth + \cellwidth*2, 0)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (0,0) -- (\cellwidth,-\cellwidth*2);
            \node[shift={(2 + \W*\cellwidth + \cellwidth*2, 0)}, right, rotate=0] at (\cellwidth*0.5,0) {$\small{\Cin}$};
            \draw[shift={(5 + \W*\cellwidth + \cellwidth*2, 0)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (0,0) -- (\cellwidth*0.5,-\cellwidth);
            \node[shift={(5 + \W*\cellwidth + \cellwidth*2, 0)}, right, rotate=0] at (\cellwidth*0.65,0) {$\small{\Cout}$};
            %
            \draw (\cellwidth*3,\cellwidth) node {$\mathbf{w}$};
            %
            \draw (1.875,-\cellwidth*1-\cellwidth*0.5*\H) node {$\star$};

            % draw signal in
            \foreach \c in {1,...,\NchannelsIn} {
                    \foreach \x in {1,...,\H} {
                            \foreach \y in {1,...,\W} {
                                    \draw [shift={(2 + \c*\cellwidth*0.5, -\c*\cellwidth*0.5)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                                }
                        }
                }
            % draw W
            \draw[shift={(2 + \NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*\W+\cellwidth,-\cellwidth*\H-\cellwidth*0.5) -- (\cellwidth*1,-\cellwidth*\H-\cellwidth*0.5);
            \node[shift={(2 + \NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5)}, below, rotate=0] at (\cellwidth*\W*0.5+\cellwidth*1,-\cellwidth*\H-\cellwidth*1) {$\small{M}$};
            %
            \draw[shift={(2.25 + \cellwidth*0.5*\W, 0)}] (\cellwidth*0.25,\cellwidth) node {$\xin$};

            % draw signal out
            \foreach \c in {1,...,\NchannelsOut} {
                    \foreach \x in {1,...,\H} {
                            \foreach \y in {1,...,\W} {
                                    \draw [shift={(5 + \c*\cellwidth*0.5, -\c*\cellwidth*0.5)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                                }
                        }
                }
            % draw H
            \draw[shift={(5 + \NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*\W+\cellwidth,\cellwidth*0.5) -- (\cellwidth*\W+\cellwidth,-\cellwidth*\H+\cellwidth*0.5);
            \node[shift={(5 + \NchannelsIn*\cellwidth*0.5, -\NchannelsIn*\cellwidth*0.5)}, right, rotate=0] at (\cellwidth*\W+\cellwidth*1.5,-\cellwidth*\H*0.5+\cellwidth*0.5) {$\small{N}$};
            %
            \draw (4.875,-\cellwidth*1-\cellwidth*0.5*\H) node {$=$};
            %
            \draw[shift={(5 + \cellwidth*0.5*\W, 0)}] (\cellwidth*1.25,\cellwidth) node {$\xout$};
        \end{tikzpicture}
    }
    \caption{Multichannel convolution.}
    \label{fig:convolutional_neural_networks:multichannel_conv}
\end{figure}

It's important to get comfortable with the shapes of the data and parameter tensors that get processed through different neural architectures. This is essential when designing and building these architectures, and when analyzing and debugging them. Let's go through an example with concrete numbers. Consider data $\xin$, which is an RGB image of size $128 \times 128$ pixels. We will pass it through a convoluational layer that applies a bank of $3 \times 3$ filters (this refers to the spatial extent of the filters). We omit the bias terms for simplicity. The output ends up being a $96 \times 128 \times 128$ tensor, as shown in \fig{\ref{fig:convolutional_neural_nets:multichannel_conv_diagram}}.
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.65\linewidth]{./figures/convolutional_neural_nets/multichannel_conv_diagram.pdf}}
    \caption{A convolutional layer that applies a bank of $3 \times 3$ filters. How many parameters does each filter have? How many filters are in the filter bank? \textit{Source}: created by Jonas Wulff.}
    \label{fig:convolutional_neural_nets:multichannel_conv_diagram}
\end{figure}

To check your understanding, you should be able to answer the following questions:
\begin{enumerate}
    \item How many parameters does each filter have? (A) 9, (B) 27, (C) 96, (D) 864
    \item How many filters are in the filter bank? (A) 3, (B) 27, (C) 96, (D) can't say
\end{enumerate}
The answers are given in the footnote.\footnote{The answers are 1-B, 2-C.}

%Each subsequent layer of neurons is a feature map of size $M_l \times N_l \times C_l$ for the $l$-th layer. In the example with $K$ output channels, $C_l = K$.

%These layers can then be stacked one after the other, with a pointwise nonlinearity in between, just like we did with linear layers in Chapter 9. %\ref{chapter:neural_nets}

\subsection{Strided Convolution}
\index{Convolutional layer!Strided}

Convolutional layers, as defined previously, maintain the spatial resolution of the signal they process. However, commonly it is sufficient, or even desirable, to output a lower resolution. This can be achieved with strided convolution:
\begin{align}
    \xoutnonbold[n,m] =
    b + \sum_{k_1,k_2=-K}^K w[k_1,k_2] \xinnonbold[s_n n-k_1,s_m m-k_2] & \quad\quad \triangleleft \quad \texttt{conv}\quad \text{(strided)}\label{eqn:convolutional_neural_nets:convolutional_filter_strided}
\end{align}
where $s_n$ and $s_m$ are the strides in the vertical and horizontal directions, respectively.
\marginnote{Here and below, we define operations for the simplest case of convolution of a single square filter with a single channel 2D signal. All these operations can be straightforwardly extended for the multichannel in, multichannel out case, and for ND signals, and for non-square kernels. We leave it as an exercise for the reader to write out these variations as needed.}[-1.4cm]

Commonly we use the same stride $s_n = s_m = s$. A convolution layer with these strides performs a mapping $\mathbb{R}^{M \times N} \rightarrow \mathbb{R}^{N/s_n \times M/s_m}$. In order to make this mapping well-defined, we require that $N$ or $M$ are divisible by $s_n$ and $s_m$, respectively; if they are not, we may may pad (or crop) the input until they are.

Strided convolution looks like this (\fig{\ref{fig:convolutional_neural_networks:strided_conv_diagram}}):
% \begin{figure}[h]
% \centerline{
%     \includegraphics[width=0.45\linewidth]{./figures/convolutional_neural_nets/strided_conv_diagram.pdf}}
%     \caption{Strided convolution.}
%     \label{fig:convolutional_neural_nets:strided_conv_diagram}
% \end{figure}
\begin{figure}[h!]
    \centerline{
        \begin{tikzpicture}
            \def\Hin{11}
            \def\Win{11}
            \def\Hout{3}
            \def\Wout{3}
            \def\K{3}
            \def\cellwidth{0.25}
            \def\stride{4}

            % draw filter
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \draw [fill=param_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};
            %
            \draw (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K-\cellwidth) node {filter};
            %
            \draw (\cellwidth*\K + 3*\cellwidth,-\cellwidth*\K*0.5+\cellwidth) node {$\star$};

            % draw signal in
            \foreach \x in {1,...,\Hin} {
                    \foreach \y in {1,...,\Win} {
                            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\Win*0.5+\cellwidth,-\cellwidth*\Hin-\cellwidth) node {$\xin$};
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*4.5,2*\cellwidth) node {stride};
            \draw[shift={(\cellwidth*\K + 4.5*\cellwidth,\cellwidth+0.1)}, decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*2,-\cellwidth) -- (\cellwidth*6,-\cellwidth);

            % draw overlaid filters
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, fill=param_color, opacity=0.5] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, thick] (\cellwidth*1,0) rectangle ++(\cellwidth*\K,-\cellwidth*\K);
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};
            %
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \draw [shift={(\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride)}, fill=param_color, opacity=0.5] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride)}, thick] (\cellwidth*1,0) rectangle ++(\cellwidth*\K,-\cellwidth*\K);
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};
            %
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \draw [shift={(\cellwidth*\stride+\cellwidth*\K + 4*\cellwidth,0)}, fill=param_color, opacity=0.5] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            \draw [shift={(\cellwidth*\stride+\cellwidth*\K + 4*\cellwidth,0)}, thick] (\cellwidth*1,0) rectangle ++(\cellwidth*\K,-\cellwidth*\K);
            %
            \draw [shift={(\cellwidth*\stride+\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};
            %
            \draw [shift={(\cellwidth*\stride*1.75+\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\cdots$};
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride*1.75)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\vdots$};
            \draw [shift={(\cellwidth*\stride*0.75+\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride*0.75)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {\rotatebox[origin=c]{45}{$\vdots$}};

            %
            \draw (\cellwidth*\K + 7*\cellwidth + \cellwidth*\Win,-\cellwidth*\K*0.5+\cellwidth) node {$=$};

            % draw signal out
            \foreach \x in {1,...,\Hout} {
                    \foreach \y in {1,...,\Wout} {
                            \draw [shift={(\cellwidth*\K + 8*\cellwidth + \cellwidth*\Win,0)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw [shift={(\cellwidth*\K + 8*\cellwidth + \cellwidth*\Win,0)}] (\cellwidth*\Wout*0.5+\cellwidth,-\cellwidth*\Hout-\cellwidth) node {$\xout$};
        \end{tikzpicture}
    }
    \caption{Strided convolution.}
    \label{fig:convolutional_neural_networks:strided_conv_diagram}
\end{figure}
\vspace{-0.5cm}

Strided convolutions can significantly reduce the computational cost and memory requirements when a neural network is large. However, strided convolution can decrease the quality of the convolution. Let's look at one concrete example where the kernel is the 2D Laplacian:
\begin{equation}
    \mathbf{w} =
    \begin{bmatrix}
        0 ~  & -1 ~ & 0  \\
        -1 ~ & 4 ~  & -1 \\
        0~   & -1 ~ & 0
    \end{bmatrix}
\end{equation}
As we saw in \chap{\ref{chapter:image_derivatives}}, this filter detects boundaries on images. \Fig{\ref{fig:convolutional_neural_nets:strided_conv_results}} shows an input image, and the result of strided convolution with the Laplacian kernel with strides 1, 2, and 4. The second row shows the magnitude of the discrete Fourier transforms (DFT).

\begin{figure}[h]
    $
        \begin{array}{cccc}
            \text{Input}~ & \text{Stride 1} & \text{Stride 2} & \text{Stride 4} \\
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_0.jpg}~
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_1.jpg}
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_2.jpg}
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_4.jpg}
            \\
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_0_DFT.jpg}~
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_1_DFT.jpg}
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_2_DFT.jpg}
                          &
            \includegraphics[width=.22\linewidth]{figures/convolutional_neural_nets/aliasing_stride_4_DFT.jpg}
        \end{array}
    $
    \caption{Strided convolution results and their Fourier transforms.}
    \label{fig:convolutional_neural_nets:strided_conv_results}
\end{figure}

The result with stride 1 looks fine, and it is the output we would expect. However, stride 2 starts showing some artifacts on the boundaries, and stride 4 shows very severe artifacts, with some boundaries disappearing. The DFTs make the artifacts more obvious. In the stride 2 result we can see severe aliasing artifacts that introduce new lines in the Fourier domain that are not present in the DFT of the input image.

One can argue that these artifacts might not be important when the kernel is being learned. Indeed, the learning could search for kernels that minimize the artifacts due to aliasing as those probably increase the loss. Also, as each layer is composed of many channels, the set of learned kernels could learn to compensate for the aliasing produced by other channels. However, this reduces the space of useful kernels, and the learning might not succeed in removing all the artifacts.

%this means that some of the strided filters will partially overlap the image boundaries.

%How we handle this case depends on our choice of padding convention. One option is to simply discard any filters that overlap the boundaries (called `valid'), resulting in the output dimensionality being .


\subsection{Dilated Convolution}
% references: https://arxiv.org/pdf/1606.00915.pdf
% https://arxiv.org/pdf/1511.07122v3.pdf
\index{Convolutional layer!Dilated}

Dilated convolution is similar to strided convolution but spaces out the \textit{filter} itself rather than spacing out where the filter is applied to the image:
\begin{align}
    \xoutnonbold[n,m] =
    b + \sum_{k_1,k_2=-K}^K w[k_1,k_2] \xinnonbold[n-d_kk_1,m-d_kk_2] & \quad\quad \triangleleft \quad \texttt{conv}\quad \text{(dilated)}\label{eqn:convolutional_neural_nets:convolutional_filter_dilated}
\end{align}
\marginnote{Here we dilate by factor $d_k$ in both spatial dimensions but we could choose a different dilation in each dimension. Or, we could even dilate in the channel dimension, if we were using a multichannel convolution, but this is uncommon.}[-3cm]
An example of a dilated filter is visually shown in \fig{\ref{fig:convolutional_neural_networks:dilated_conv_diagram}}:
%Visually it looks like this, where the filter weights are shaded blue:
% \begin{figure}[h]
% \centerline{
%     \includegraphics[width=0.6\linewidth]{./figures/convolutional_neural_nets/dilated_conv_diagram.pdf}}
%     \caption{Dilated convolution.}
%     \label{fig:convolutional_neural_nets:dilated_conv_diagram}
% \end{figure}
\begin{figure}[h!]
    \centerline{
        \begin{tikzpicture}
            \def\Hin{10}
            \def\Win{10}
            \def\Hout{10}
            \def\Wout{10}
            \def\K{5}
            \def\cellwidth{0.25}
            \def\stride{4}

            % draw filter
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \pgfmathparse{int(mod(\x,2)==1 && mod(\y,2)==1)}
                            \ifnum\pgfmathresult=1
                                \def\fillcolor{param_color}
                            \else
                                \def\fillcolor{zero_color}
                            \fi
                            \draw [fill=\fillcolor] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};
            %
            \draw (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K-\cellwidth) node {filter};
            %
            \draw (\cellwidth*2.5,\cellwidth*2) node {dilation};
            \draw [decorate,decoration={brace, amplitude=5pt, angle=0}] (\cellwidth*1.5,0.1) -- (\cellwidth*3.5,0.1);
            %
            \draw (\cellwidth*\K + 3*\cellwidth,-\cellwidth*\K*0.5) node {$\star$};

            % draw signal in
            \foreach \x in {1,...,\Hin} {
                    \foreach \y in {1,...,\Win} {
                            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\Win*0.5+\cellwidth,-\cellwidth*\Hin-\cellwidth) node {$\xin$};

            % draw overlaid filters
            \foreach \x in {1,...,\K} {
                    \foreach \y in {1,...,\K} {
                            \pgfmathparse{int(mod(\x,2)==1 && mod(\y,2)==1)}
                            \ifnum\pgfmathresult=1
                                \def\fillcolor{param_color}
                            \else
                                \def\fillcolor{zero_color}
                            \fi
                            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, fill=\fillcolor, opacity=0.5] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}, thick] (\cellwidth*1,0) rectangle ++(\cellwidth*\K,-\cellwidth*\K);
            %
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\mathbf{w}$};

            % draw ...'s
            \draw [shift={(\cellwidth*\stride*1+\cellwidth*\K + 4*\cellwidth,0)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\cdots$};
            \draw [shift={(\cellwidth*\K + 4*\cellwidth,-\cellwidth*\stride*0.9)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {$\vdots$};
            \draw [shift={(\cellwidth*\K + 4*\cellwidth+\cellwidth*\stride*0.8,-\cellwidth*\stride*0.8)}] (\cellwidth*\K*0.5+\cellwidth,-\cellwidth*\K*0.5) node {\rotatebox[origin=c]{45}{$\vdots$}};

            %
            \draw (\cellwidth*\K + 7*\cellwidth + \cellwidth*\Win,-\cellwidth*\K*0.5) node {$=$};

            % draw signal out
            \foreach \x in {1,...,\Hout} {
                    \foreach \y in {1,...,\Wout} {
                            \draw [shift={(\cellwidth*\K + 8*\cellwidth + \cellwidth*\Win,0)}, fill=data_color] (\cellwidth*\x,-\cellwidth*\y) rectangle ++(\cellwidth,\cellwidth);
                        }
                }
            %
            \draw [shift={(\cellwidth*\K + 8*\cellwidth + \cellwidth*\Win,0)}] (\cellwidth*\Wout*0.5+\cellwidth,-\cellwidth*\Hout-\cellwidth) node {$\xout$};
        \end{tikzpicture}
    }
    \caption{Dilated convolution. Dark gray cells have value 0.}
    \label{fig:convolutional_neural_networks:dilated_conv_diagram}
\end{figure}

As can be seen in the visualization, dilation is a way to achieve a filter with large kernel while only requiring a small number of weights. The weights are just spaced out so that a few will cover a bigger region of the image.

As was the case with strided convolution, dilation can also introduce artifacts. Let's look at one example in detail that illustrates the effect of dilation on a filter. Let's consider the blur kernel, $b_{2,2}$:
\begin{equation}
    \mathbf{w} = \frac{1}{16}
    \begin{bmatrix}
        1 ~ & 2 ~ & 1 \\
        2 ~ & 4 ~ & 2 \\
        1~  & 2 ~ & 1
    \end{bmatrix}
\end{equation}
This filter blurs the input image by computing the weighted average of pixel intensities around each pixel location. But, dilation transforms this filter in ways that change the behavior of the filter, which does not behave as a blur filter any longer.
\marginnote{We saw that the 1D signal $[-1, 1, -1, ...]$ convolved with $[1,2,1]$ outputs zero. However, check what happens when we convolve the input with the dilated kernel $[1, 0, 2, 0, 1]$.}[-1.5cm]
The next figure shows the kernel with dilations $d_k=1$, $d_k=2$, and $d_k=4$ together with the magnitude of the DFT of the three resulting kernels (\fig{\ref{fig:convolutional_neural_nets:aliasing_dilated_kernel_binomial}}).


\begin{figure}[h]
    \centerline{
        \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/aliasing_dilated_kernel_binomial.eps}}
    \caption{Dilated filters and their Fourier transforms.}
    \label{fig:convolutional_neural_nets:aliasing_dilated_kernel_binomial}
\end{figure}
\vspace{-0.4cm}

When using the original binomial filter (which corresponds to $d_k=1$) the DFT shows that the filter is a low-pass filter. When applying dilation ($d_k=2$) the DFT changes and it is not unimodal anymore. It has now eight additional local maximum in high spatial frequencies. With $d_k=4$, the DFT reveals an even more complex frequency behavior. \Fig{\ref{fig:convolutional_neural_nets:dilated_blur_mit_dome_example}} shows one input image and the result of the dilated convolutions with the blur kernel, $b_{2,2}$, with dilations $d_k=1$, $d_k=2$, and $d_k=4$.
\begin{figure}[h!]
    \centerline{
        $
            \begin{array}{cccc}
                \text{input}~ & d_k=1 & d_k=2 & d_k=4 \\
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_1.jpg}~
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_2.jpg}
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_3.jpg}
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_4.jpg}
                \\
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_1_DFT.jpg}~
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_2_DFT.jpg}
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_3_DFT.jpg}
                              &
                \includegraphics[width=.2\linewidth]{figures/convolutional_neural_nets/aliasing_dilated_4_DFT.jpg}
            \end{array}
        $
    }
    \caption{Result of the dilated convolutions with the blur kernel, $b_{2,2}$, with dilations $d_k=1$, $d_k=2$, and $d_k=4$.}
    \label{fig:convolutional_neural_nets:dilated_blur_mit_dome_example}
\end{figure}
\vspace{-0.4cm}

In summary, using dilation increases the size of the convolution kernels without increasing the computations (which is the original desired property) but it reduces the space of useful kernels (which is an undesired property).

There are  ways in which dilation can be used to increase the family of useful filters. For instance, by composing three convolutions with $d_k=1$, $d_k=2$, and $d_k=4$ together (\fig{\ref{fig:convolutional_neural_networks:dilated_conv_cascade}}), one can create a kernel that can switch during learning between high and low spatial frequencies and small and large kernels.
% \begin{figure}[h]
% \centerline{
%     \includegraphics[width=.6\linewidth]{./figures/convolutional_neural_nets/dilated_conv_cascade.eps}}
%     \caption{Convolving dilated filters creates a new filter that can measure effects at a mixture of frequencies.}
%     \label{fig:convolutional_neural_nets:dilated_conv_cascade}
% \end{figure}
\begin{figure}[h!]
    \centerline{
        \begin{tikzpicture}
            \def\K{{0,3,5,9}}
            \def\dilation{{0,1,2,4}}
            \def\cellwidth{0.25}
            \def\shift{{0,0,6,14}}

            % draw filters
            \foreach \i in {1,...,3} {
                    \pgfmathparse{\shift[\i]} \let\shifti=\pgfmathresult
                    \pgfmathparse{\K[\i]} \let\Ki=\pgfmathresult
                    \pgfmathparse{\dilation[\i]} \let\dilationi=\pgfmathresult

                    \foreach \x in {1,...,\Ki} {
                            \foreach \y in {1,...,\Ki} {

                                    \pgfmathparse{\x-1} \let\xminusone=\pgfmathresult
                                    \pgfmathparse{\y-1} \let\yminusone=\pgfmathresult

                                    \pgfmathparse{int(mod(\xminusone,\dilationi)==0 && mod(\yminusone,\dilationi)==0)}
                                    \ifnum\pgfmathresult=1
                                        \def\fillcolor{param_color}
                                    \else
                                        \def\fillcolor{zero_color}
                                    \fi
                                    \draw [shift={(\shifti*\cellwidth,0)}, fill=\fillcolor] (\cellwidth*\x,-\cellwidth*\y+\Ki*0.5*\cellwidth) rectangle ++(\cellwidth,\cellwidth);
                                }
                        }
                    %
                    \ifnum\i<3:
                        \draw [shift={(\shifti*\cellwidth+\Ki*\cellwidth+2.5*\cellwidth,0)}] (0,0) node {$\star$};
                    \fi
                }
        \end{tikzpicture}
    }
    \caption{Convolving dilated filters creates a new filter that can measure effects at a mixture of frequencies.}
    \label{fig:convolutional_neural_networks:dilated_conv_cascade}
\end{figure}

This results in a kernel with a size of $9 \times 9$ (81 values) defined by 27 values. The relative computational efficiency increases when we cascade more filters with higher levels of dilation. \Fig{\ref{fig:convolutional_neural_nets:kernels_resulting_from_dilated_filters}} shows several multiscale kernels that can be obtained by the convolutions of three dilated kernels. Can you guess which kernels were used?

\begin{figure}[h]
    \centerline{
        \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/dilated_examples.eps}}
    \caption{Example kernels that each result from convolving three filters.}
    \label{fig:convolutional_neural_nets:kernels_resulting_from_dilated_filters}
\end{figure}

As the figure shows, the cascade of three dilated convolutions can generate a large family of filters with different scales, orientations, shifts, and also other patterns such as corner detectors, long edge detectors, and curved edge detectors. The last four kernels shows the result of convolving three random kernels, which provides further illustration of the diversity of kernels one can build. Each kernel is a $3 \times 3$ array sampled from a Gaussian distribution.

\subsection{Low-Rank Filters}
Dilation is one way to create a big filter that is parameterized by just a small number of weights, that is, a low-rank filter. This trick can be useful in many contexts where we know that good filters have low-rank structure. Dilation uses this trick to make big kernels, which can capture long-range dependences.

Separable filters are another kind of low-rank filter that is useful in many applications (see \chap{\ref{chapter:fourier_analysis}}). We can create a convolutional layer with separable filters by simply stacking two convolutional layers in sequence, with no other layers in between. The first layer is a filter bank with $K \times 1$ kernels and the second uses $1 \times K$ kernels. The composition of these layers is equivalent to a single convolutional layer with $K \times K$ separable filters. Two examples of such separable filters are given below (\fig{\ref{fig:convolutional_neural_nets:kernels_separable_aprox}}):

\marginnote{When convolving one row and one column vector, $\mathbf{w} = \mathbf{u}^\transpose \circ \mathbf{v}$, the result is the outer product: $w \left[n,m \right] = u\left[n \right] v\left[m \right]$.}[-2cm]

\begin{figure}[h]
    \centerline{
        \includegraphics[width=.6\linewidth]{./figures/convolutional_neural_nets/kernels_separable_aprox.eps}}
    \caption{Two examples of separable filters.}
    \label{fig:convolutional_neural_nets:kernels_separable_aprox}
\end{figure}
\vspace{-0.4cm}

Some important kernels are nonseparable but can be approximated by a linear combination of a small number of separable filters. For instance, the Gaussian Laplacian is nonseparable but can be approximated by a separable filter as shown here (\fig{\ref{fig:convolutional_neural_nets:laplacian_separable_aprox}}):
\begin{figure}[h]
    \centerline{
        \includegraphics[width=.6\linewidth]{./figures/convolutional_neural_nets/laplacian_separable_aprox.eps}}
    \caption{Approximating a Gaussian Laplacian filter as the outer product of two 1D filters.}
    \label{fig:convolutional_neural_nets:laplacian_separable_aprox}
\end{figure}
\vspace{-0.4cm}

The diagonal Gaussian derivative is another nonseparable kernel. When using a $3 \times 3$ kernel to approximate it we have:
\begin{equation}
    \mathbf{w} =
    \begin{bmatrix}
        0 ~ & -2 ~ & -2 \\
        2 ~ & 0 ~  & -2 \\
        2~  & 2 ~  & 0
    \end{bmatrix}
\end{equation}
But we know from \chap{\ref{chapter:image_derivatives}} that this kernel can be written as a linear combination of two separable kernels: $\mathbf{w} = \text{Sobel}_x + \text{Sobel}_y$, as defined in \eqn{\ref{eq:sobel_kernels}}. In general, any $M \times N$ filter can be decomposed as a linear sum of $min(N,M)$ separable filters. The separable filters can be obtained by applying the singular value decomposition (SVD) to the kernel array $\mathbf{w}$. The SVD results in three matrices, $\mathbf{U}$, $\mathbf{S}$ and $\mathbf{V}$, so that $\mathbf{w} = \mathbf{U} \mathbf{S} \mathbf{V}^\transpose$, where the columns of $\mathbf{U}$ and $\mathbf{V}$ are the separable 1D filters and the diagonal values of the diagonal matrix $\mathbf{S}$ are the linear weights. Computational benefits are only obtained when using small linear combinations for large kernels. Also, in a neural network, one could use only separable filters for all the units and the learning could discover ways of combining them in order to build more complex, nonseparable kernels.

% \subsection{Cross-correlation layers}
% Most implementations of ``convolution" layers actually use cross-correlation rather than convolution, computing $\mathbf{w} \star \xin + b$. The reason we do not worry about the misnomer is that whether you implement the layers with convolution or cross-correlation usually makes no difference for learning. This is because convolution and cross-correlation \textit{span an identical hypothesis space} (any cross-correlation can be converted to an equivalent convolution by flipping the filter horizontally and vertically). However, sometimes it will be important to know whether the filters are doing convolution or cross-correlation. This may come up when examining the learned filters and trying to understand them, or when manipulating filters post-learning.%}[-1.2cm]


\subsection{Downsampling and Upsampling Layers}

%As we saw in the previous chapters on Image Modeling, images can be efficiently represented with a multiscale pyramid, where we downsample the representation after each stage of filtering. The equivalent idea in CNNs is to insert downsampling layers, which simply downsample the feature map on one layer to a smaller feature map on the next layer. This can be done by any of a number of subsampling routines, including averaging then subsampling, which is called {\bf average pooling}, taking the max within a window then subsampling, which is called {\bf max pooling}, or even just subsampling the feature map directly, which is called {\bf strided convolution}.

In \chap{\ref{chapter:image_pyramids}} we saw image pyramids and showed how they can be used for analysis and synthesis. CNNs can also be structured as analysis and synthesis pyramids, and this is a very powerful tool. To create a pyramid we just need to introduce a way of downsampling the signal during analysis and upsampling during synthesis. In CNNs this is done with \index{Downsampling layer}\index{Upsampling layer}{\bf downsampling and upsampling layers}.

%It is often useful to change the resolution at which we are processing a signal. This is the idea behind multiscale representations like image pyramids, and we would like layers in a CNN that can achieve the same kind of multiscale processing. To create multiscale representations in a CNN we will use {\bf downsampling layers} and {\bf upsampling layers}.

Downsampling layers transform the input tensor to an output tensor that is smaller in the spatial dimensions: $\mathbb{R}^{N \times M} \rightarrow \mathbb{R}^{N/s_n \times M/s_m}$. We already saw one kind of downsampling layer, strided convolution, which is equivalent to convolution followed by subsampling. Another common kind of downsampling layer is \index{Pooling layer}{\bf pooling}, which we will encounter in \sect{\ref{sec:convolutional_neural_nets:pooling_layers}}.

Upsampling layers perform the opposite transformation, outputting a tensor that is larger in the spatial dimensions than the input: $\mathbb{R}^{N \times M} \rightarrow \mathbb{R}^{Ns_n \times Ms_m}$. One kind of upsampling layer can be made as the analogue of strided convolution. Strided convolution convolves then subsamples; this upsampling layer instead dilates the signal then convolves. Starting with a blank image of zeros, $\mathbf{h} = \mathbf{0}$, we set:
\begin{align}
    h[ns_n, ms_m] & = \xinnonbold[n, m]               & \quad\quad \triangleleft \quad \texttt{dilation}\label{eqn:convolutional_neural_nets:dilation} \\
    \xout         & = \mathbf{w} \star \mathbf{h} + b & \quad\quad \triangleleft \quad \texttt{conv}
\end{align}
\marginnote{This equation applies for all integer values of $n \in \{1,\ldots,N\}$ and $m \in \{1,\ldots,M\}$.}[-1.2cm]
Sometimes the combination of these two layers is called an UpConv layer or a deconvolution layer (but note that deconvolution has a different meaning in signal processing).
%Dilation is the inverse operation to subsampling in the sense that $\texttt{subsample}(\texttt{dilate}(\mathbf{x})) = \mathbf{x}$, but note that the opposite ordering does not yield equality.

%To upsample one option is to first dilate the tensor, then pass the dilated $\xin$ to a conv layer.

\section{Nonlinear Filtering Layers}

All the operations we have covered above are linear (or affine). It is also possible to define filters that are nonlinear. Like convolutional filters, these filters slide across the input tensor and process each window identically and independently, but the operation they perform is a nonlinear function of the local window.

\subsection{Pooling Layers}\label{sec:convolutional_neural_nets:pooling_layers}

{\bf Pooling layers} are downsampling layers that summarize the information in a patch using some aggregate statistic, such as the patch's mean value, called \index{Pooling layer!Mean pooling}{\bf mean pooling}, or its max value, called \index{Pooling layer!Max pooling}{\bf max pooling}, defined as follows:
\begin{align}
    \xouti = \max_{i \in \mathcal{N}(i)} \xini                         & \quad\quad \triangleleft \quad \texttt{max pooling}\label{eqn:convolutional_neural_nets:max_pooling}   \\
    \xouti = \frac{1}{|\mathcal{N}|} \sum_{i \in \mathcal{N}(i)} \xini & \quad\quad \triangleleft \quad \texttt{mean pooling}\label{eqn:convolutional_neural_nets:mean_pooling}
\end{align}
\marginnote{The $\mathcal{N}(i)$ indicates the set of indices in the same patch as index $i$.}[-1.6cm]

Like all downsampling layers, pooling layers can be used to reduce the resolution of the input tensor, removing high-frequency information in the signal. Pooling is also particularly useful as a way to achieve \textit{invariance}. Convolutional layers produce outputs that are equivariant to translations of their input. Pooling is a way to convert equivariance into invariance. For example, suppose we have run a convolutional filter that detects vertical edges. The output is a response map that is large wherever there was a vertical edge in the input image. Now if we run a max pooling filter across this response map, it will coarsen the map, resulting in a large response anywhere \textit{near} where there was a vertical edge in the input image. If we use a max pooling filter with large enough neighborhood $\mathcal{N}$, the output will be invariant to the location of the edge in the input image.

Pooling can also be performed across channels, and this can be a way to achieve additional kinds of invariance. For example, suppose we have a convolutional layer that applies a filter bank of oriented edge detector filters, where each filter looks for edges at a different orientation. Now if we max pool across the channels output by this filter bank, the resulting feature map will be large wherever an edge of \textit{any} orientation was found. Normally, we are not looking for edges but for more complicated patterns, but the same logic applies. First run a bank of filters that look for the pattern at $k$ different orientations. Then pool across these $k$ channels to detect the pattern regardless of its orientation. This can be a great way for a CNN to recognize objects even if they appear with various rotations within the image. Of course we usually do not hand-define this strategy but it is one the CNN can learn to use if given channelwise pooling layers.


%For example, consider that we want to detect a pattern regardless of exactly where it appears in an image. First we convolve with a filter that detects the pattern. Then, if we apply a max pooling filter of size $N \times N$, the response map will be invariant to translations of the pattern 

\subsection{Global Pooling Layers}
\index{Pooling layer!Global pooling}

One extreme of pooling is to pool over the entire spatial extent of the feature map. Global pooling is a function that maps a $C \times M \times N$ tensor into a vector of length $C$, where $C$ is the number of channels in the input.

Global pooling is generally used in layers very close to the output. As before, global pooling can be {\bf global average pooling}, averaging over all the responses of the feature map, or {\bf global max pooling}, taking the max of the feature map.

Global pooling removes spatial information from each channel. However, spatial information about input features might be still be available within the output vector if different channels learn to be sensitive to features at different spatial positions.

\subsection{Local Normalization Layers}

Another kind of nonlinear filter is the {\bf local normalization layer}. These layers normalize each activation in a feature map by statistics the adjacent activations within some neighborhood. There are many different choices for the type of normalization ($L_1$ norm, $L_2$ norm, standardization, etc.) and many different choices for the shape of the neighborhood, such as a square patch in the spatial dimensions, a set of channels, and so on. Each of these choices leads to different kinds of normalization filters with different names. One that is historically important but no longer frequently used is the \index{Local response normalization}{\bf local response normalization}, or {\bf LRN}, filter that was introduced in the AlexNet paper~\cite{krizhevsky2012imagenet}. This filter has the following form:
%\begin{align}
%    \textcolor{data_color}{\xoutk}[n,m] = \textcolor{data_color}{\xink}/ \left( \textcolor{param_color}{\gamma} + \textcolor{param_color}{\alpha} \sum_{i=\max(1,k-\textcolor{param_color}{l})}^{\max(K,k+\textcolor{param_color}{l})} \textcolor{data_color}{\xini}[n,m]^2 \right) ^{\textcolor{param_color}{\beta}} \quad\quad \triangleleft \quad\texttt{LRN} \label{eqn:convolutional_neural_nets:LRN}
%\end{align}
\begin{align}
    \xoutnonbold[c,n,m] = \xinnonbold[c,n,m] / \left( \gamma + \alpha \sum_{i=\max(1,c-l)}^{\max(C,c+l)} \xinnonbold[i,n,m]^2 \right) ^\beta \quad\quad \triangleleft \quad\texttt{LRN} \label{eqn:convolutional_neural_nets:LRN}
\end{align}
where $\alpha$, $\beta$, $\gamma$, and $l$ are hyperparameters of the layer. This layer normalizes each activation by the sum of squares of the activations in a window of adjacent \textit{channels}.

Although local normalization is a common structure within the brain, it is not very frequently used in current neural networks, which more often use global normalization layers like batchnorm or layernorm (which we saw in \chap{\ref{chapter:neural_nets}}).


\section{A Simple CNN Classifier}
\label{sec:convolutional_neural_nets:simple_CNN}

CNNs are deep nets that stack convolutional layers in a series, interleaved with nonlinearities. CNNs also frequently use downsampling and upsampling layers, pooling layers, and normalization layers, as described above.

CNNs come in a large variety of architectures, each suited to a different kind of problem. We will see some of these architectures in \sect{\ref{sec:convolutional_neural_nets:popular_architectures}}. For now we will focus on just one simple architecture that is suited to image classification. This architecture progressively downsamples the image until the last layer makes a single global prediction of the image label (\fig{\ref{fig:convolutional_neural_nets:convnet_motif}}):
%Stacking sequences of layers $\texttt{conv}, \texttt{non-linearity}, \texttt{subsample}$ over and over results in a prototypical motif of CNNs:
\begin{figure}[h]
    \centerline{
        \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/convnet_motif.pdf}}
    \caption{A CNN architecture for image classification. {\em Photo source}: Fredo Durand.}
    \label{fig:convolutional_neural_nets:convnet_motif}
\end{figure}

%This structure is common for CNNs whose goal is to take an image as input and produce a label as output, such as in the problem of image classification. 

We will now walk through an example of such a classifier. Let $\mathbf{x} \in \mathbb{R}^{M \times N}$ be a black and white image. To process this image, we could use a simple CNN with two convolutional layers, defined as follows:
%\begin{align}
%    \mathbf{z}_1 &= \mathbf{w}_1 \circ \mathbf{x} + \mathbf{b}_1 &\triangleleft \quad \texttt{conv}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{h}_1 &= \max(\mathbf{z}_1,0) &\triangleleft \quad \texttt{relu}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{z}_2 &= \mathbf{w}_2 \circ \mathbf{h}_1 +\mathbf{b}_2 &\triangleleft \quad \texttt{conv}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{y}_i &= \frac{e^{-\tau \mathbf{z}_{2_i}}}{\sum_{k=1}^K e^{-\tau \mathbf{z}_{2_k}}} &\triangleleft \quad \texttt{softmax}: [M \times N] \rightarrow [M \times N]
%\end{align}

%\begin{align}
%    \mathbf{z}_1 &= \mathbf{w}_1 \circ \mathbf{x} + \mathbf{b}_1 &\triangleleft \quad \texttt{conv}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{z}_2 &= \mathbf{w}_2 \circ \mathbf{x} + \mathbf{b}_2 &\triangleleft \quad \texttt{conv}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{h}_1 &= \max(\mathbf{z}_1,0) &\triangleleft \quad \texttt{relu}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{h}_2 &= \max(\mathbf{z}_1,0) &\triangleleft \quad \texttt{relu}: [M \times N] \rightarrow [M \times N]\\
%    \mathbf{z}_{1,2} &= \sum_{n,m} \mathbf{h}_1[n,m]  &\triangleleft \quad \texttt{gap}: [M \times N] \rightarrow [1]\\
%    \mathbf{z}_{2,2} &= \sum_{n,m} \mathbf{h}_2[n,m]  &\triangleleft \quad \texttt{gap}: [M \times N] \rightarrow [1]\\
%    \mathbf{z}_{1,3} &= a \mathbf{z}_{1,2} + b \mathbf{z}_{2,2} &\triangleleft \quad \texttt{fc}: [2] \rightarrow [1]\\
%    \mathbf{z}_{2,3} &= c \mathbf{z}_{1,2} + d \mathbf{z}_{2,2} &\triangleleft \quad \texttt{fc}: [2] \rightarrow [1]\\
%    \mathbf{y}_i &= \frac{e^{-\tau \mathbf{z}_{i,3}}}{\sum_{k=1}^K e^{-\tau \mathbf{z}_{k,3}}} &\triangleleft \quad \texttt{softmax}: [2] \rightarrow [2]
%\end{align}


\begin{align}
    \mathbf{z}_1[c,:,:] & = \mathbf{w}[c,:,:] \star \mathbf{x} + b[c]              & \triangleleft \quad \texttt{conv}: [M \times N] \rightarrow [C \times M \times N]          \\
    h[c,n,m]            & = \max(z_1[c,n,m],0)                                     & \triangleleft \quad \texttt{relu}: [C \times M \times N] \rightarrow [C \times M \times N] \\
    z_2[c]              & = \frac{1}{NM} \sum_{n,m} h[c,n,m]                       & \triangleleft \quad \texttt{gap}: [C \times M \times N] \rightarrow [C]                    \\
    \mathbf{z}_{3}      & = \mathbf{W} \mathbf{z}_{2} + \mathbf{c}                 & \triangleleft \quad \texttt{fc}: [C] \rightarrow [K]                                       \\
    y[k]                & = \frac{e^{-\tau z_3[k]}}{\sum_{l=1}^K e^{-\tau z_3[l]}} & \triangleleft \quad \texttt{softmax}: [K] \rightarrow [K]
\end{align}
\marginnote{Note that these equations apply for all $c \in \{0,\ldots,C-1\}$, $n \in \{0,\ldots,N-1\}$ and $m \in \{0,\ldots,M-1\}$.}[-4.25cm]

This network has one convolutional layer with $C$ channels followed by a relu layer. The next layer performs spatial global average pooling (\texttt{gap}), and each channel gets projected into a single number that contains the sum of the outputs of the relu. This results in a representation given by a vector of length $C$. This vector is then processed by a \index{Fully connected layer}\textbf{fully connected layer} (\texttt{fc}). A fully connected layer is simply another name for a linear layer that is full rank, that is, every output neuron is connected to every input neuron, and the mapping is described by a $K \times C$ matrix (plus a bias).

This neural net could be used to solve a $K$-way image classification problem (because the output is a $K$-way softmax for each input image). We could train it using gradient descent to find the parameters $\theta = [\mathbf{w}_1, \ldots, \mathbf{w}_C, \mathbf{b}_1, \ldots, \mathbf{b}_C, \mathbf{W}, \mathbf{c}]$ that optimize a cross-entropy loss over training data.

%This neural net could be used to solve a $K$-way classification problem  for each location in the input image (because the output is a $K$-way softmax for each location). We could train it using gradient descent to find the parameters $\theta = [\mathbf{w}_1, \mathbf{b}_1, \mathbf{W}_2, \mathbf{b}_2]$ that optimize a cross-entropy loss over training data.

Such a network is also very easy to define in code, once we have a library of primitives for basic operations like convolution and softmax:

\begin{figure}[h]
    %\centerline{
    \begin{minipage}{1.0\linewidth}
        \begin{minted}[xleftmargin=0.075\linewidth,xrightmargin=0.075\linewidth,
fontsize=\fontsize{8.5}{9},
frame=single,
framesep=2.5pt,
baselinestretch=1.05,
]{python}
# first define parameterized layers
conv1 = nn.conv(channels_in=1, channels_out=C, kernel=k, stride=1)
fc1 = nn.fc(dim_in=C, dim_out=K)

# then run data through network
z1 = conv1(x)
h = nn.relu(z1)
z2 = nn.AvgPool2d(h)
z3 = fc1(z2)
y = nn.softmax(z3)
\end{minted}
    \end{minipage}
    %}
\end{figure}

% \begin{minted}[xleftmargin=0.0\linewidth,xrightmargin=0.0\linewidth,
% fontsize=\fontsize{8.5}{9},
% frame=single,
% framesep=2.5pt,
% baselinestretch=1.05,
% ]{python}
% t_in = conv(x_in, channels_in=3, channels_out=d, kernel=K, stride=1) # tokenize
% \end{minted}

%This neural net is a CNN -- it's a neural net that uses convolutional layers. 
%But the term CNN usually has further connotations of a particular way of stacking convolutional layers, which we describe in detail next.

\section{A Worked Example}

In this section, we will analyze the simple network described in \sect{\ref{sec:convolutional_neural_nets:simple_CNN}}, trained to discriminate between horizontal and vertical lines. Each subsection will tackle one aspect of the analysis that should be part of training any large system: (1) training and evaluation, (2) visualize and understand the network, (3) out-of-domain generalization, and (4) identifying vulnerabilities.

\subsection{Training and Evaluation}

Let's study one simple classification task. We design a simple image dataset that contains images with lines. The lines can be horizontal or vertical. Each image will contain only one type of line.

We want to design a CNN that will classify the image according to the orientation of the lines that it contains. We define the two output classes as: $0$ (vertical) and $1$ (horizontal). A few samples from the training set are shown in \fig{\ref{fig:convolutional_neural_nets:oriented_bars_cnn_trainingset}}.
\begin{figure}[h!]
    \centerline{
        \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_trainingset.eps}}
    \caption{A sample of images from the training set. The training set defines the concept we want to learn. In this case we look for lines. But images of lines might not be enough to describe the concept of a line. What is a line? This lack of a precise definition will haunt us later.}
    \label{fig:convolutional_neural_nets:oriented_bars_cnn_trainingset}
\end{figure}

To solve this problem we use the CNN defined before with two convolutional channels $C=2$ in the first layer. Once we train the network, we can see that it has solve the task perfectly and that the output on the test set is 100 percent correct (there are only three errors out of 10,000 test images). Example images from the test set are shown in \fig{\ref{fig:convolutional_neural_nets:oriented_bars_cnn_testset}}.
\begin{figure}[h!]
    \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_testset.eps}
    \caption{A sample of images from the test set. The predicted label is shown at the top.}
    \label{fig:convolutional_neural_nets:oriented_bars_cnn_testset}
\end{figure}

\subsection{Network Visualization}

What has the network learned? How is it solving the problem? One important part of developing a system is to have tools to prove, understand, and debug it.

To understand the network it is useful to {\bf visualize} the kernels. \Fig{\ref{fig:convolutional_neural_nets:oriented_bars_cnn_kernels}} shows the two learned $9 \times 9$ kernels. The first one looks like an horizontal derivative of a Gaussian filter (as we saw in \chap{\ref{chapter:image_derivatives}}) and the second one looks like a vertical derivative of a Gaussian (maybe closer to a second derivative). In fact, the DFT of each kernel shows that they are quite selective to a particular band on frequency content in the image.

\begin{figure}
    \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_kernels.eps}
    \caption{Visualization of the learned kernels.}
    \label{fig:convolutional_neural_nets:oriented_bars_cnn_kernels}
\end{figure}

The fully connected layer has learnt the weights:
\begin{equation}
    \mathbf{W} =
    \left[
        \begin{array}{cc}
            2.83  & -2.36 \\
            -0.60 & 1.14
        \end{array}
        \right]
\end{equation}
This corresponds to two channel oppositions: the  first feature is the vertical output minus the horizontal output, and the second feature computes the horizontal output minus the vertical one.

\subsection{Out-of-Domain Generalization}
\index{Out-of-distribution generalization}

What do we learn by analyzing how the trained network works? One interesting outcome is that can we predict how the network we defined before generalizes beyond the distribution of the training set, to {\bf out-of-domain test samples}.
\marginnote{Another term for out-of-domain is \textbf{out-of-distribution}.}[-0.4cm]

For instance, it seems natural to think that the network should still perform well in classifying whether the image contains vertical or horizontal structures even if they are not lines. We can test this hypothesis by generating images that match our idea of orientation. The following test images (\fig{\ref{fig:ref:convolutional_neural_nets:oriented_bars_cnn_generalization}}) contain different oriented structures but no lines, and still captures our notion of what should be the correct generalization of the behavior.

\begin{figure}
    \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_generalization.eps}
    \caption{Out-of-domain test examples. The predicted label is shown at the top.}
    \label{fig:ref:convolutional_neural_nets:oriented_bars_cnn_generalization}
\end{figure}

In fact, the network seems to perform correctly even with these new images that come from a distribution different from the training set.

\subsection{Identifying Vulnerabilities}

Does the network solve the task that we had in mind? Can we predict which inputs will make the output fail? Can we produce test examples that to us look right but for which the network produces the wrong classification output? The goal of this analysis is to identify weaknesses in the learned representation and in our training set (missing training examples, biases in our data, limitations of the architecture, etc.).

We saw that the output of the first layer does not really look for {\em lines}, instead it looks at where the energy is in the Fourier domain. So, we could fool the classifier by creating lines that for us look like vertical lines, but that have the energy content in the wrong side of the Fourier domain. We saw one trick to do this in \chap{\ref{chapter:fourier_analysis}}: modulation. If we multiply an image containing horizontal lines, by a sinusoidal wave, $\cos (\pi n / 3)$, we can move the spectral content horizontally as shown in \fig{\ref{fig:convolutional_neural_nets:oriented_bars_cnn_test_adversarial_creation1}}.

\begin{figure}
    \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_test_adversarial_creation1.eps}
    \caption{Creating a new out-of-domain test image obtained by multiplying an in-domain test image with horizontal lines (left image its DFT) with a sinusoidal wave. The resulting image and its DFT are shown on the right).}
    \label{fig:convolutional_neural_nets:oriented_bars_cnn_test_adversarial_creation1}
\end{figure}

The lines still look horizontal to us, but their spectral content now is higher in the region that overlaps with the vertical line detector learned by the network. Indeed, when the network processes images that have lines with this {\em sinusoidal texture}, it produces the wrong classification results for all the images (\fig{\ref{fig:convolutional_neural_nets:oriented_bars_cnn_test_adversarial}})!

\begin{figure}
    \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/oriented_bars_cnn_test_adversarial.eps}
    \caption{Classification results on out-of-domain test images created by modulation.}
    \label{fig:convolutional_neural_nets:oriented_bars_cnn_test_adversarial}
\end{figure}

We have just designed an \index{Adversarial example}{\bf adversarial example} manually! The question then could be as follows: If it is not detecting line orientations, what is it really detecting? Our analysis of the learned kernels had the answer. \marginnote{For complex architectures, {\bf adversarial examples} are obtained as an optimization problem: What is the minimal perturbation of an input that will produce the wrong output in the network?}[-0.9cm]

One way of avoiding this would be to introduce these types of images in the training set and to repeat the whole process.


\section{Feature Maps in CNNs}

One of the most important concepts when working with CNNs is the feature map. A feature map can be a channel of the output of a conv layer (as we defined above) or it can refer to the entire stack of channels at some layer of a network. The idea is that these are \textit{features} of the input data and the features are arranged in a \textit{map} -- an array that matches the shape of the input data. For images, feature maps are 2D spatial arrays, for videos they are 3D space-time arrays, and so forth.

\Fig{\ref{fig:convolutional_neural_nets:feature_maps_schematic}} shows the interplay between feature maps and filter banks in a CNN:
\begin{figure}[h!]
    \centerline{
        \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/feature_maps_schematic.pdf}}
    \caption{The interplay between feature maps and filters banks in a CNN. You can think of the input image itself as an R, G, B feature map and the output logits as a 1x1 resolution feature map with class logits as the channels.}
    \label{fig:convolutional_neural_nets:feature_maps_schematic}
\end{figure}

The input to the network is an image and the output is a vector of logits. We can actually think of these inputs and outputs as feature maps as well: the input is just a feature map with red, green, and blue channels and the output is a 1x1 resolution feature map with class logits as the channels.

Now let's look at the feature maps in a real network, AlexNet~\cite{krizhevsky2012imagenet}. \Fig{\ref{fig:convolutional_neural_nets:alexnet_feature_maps}} shows what these look like after the first and second convolutional layer of the network:
\begin{figure}[h!]
    \centerline{
        \includegraphics[width=1.0\linewidth]{./figures/convolutional_neural_nets/alexnet_feature_maps.pdf}}
    \caption{A selection of feature maps and filters in AlexNet. The layer 1 filter with the orange dashed border slides over the input image and produces the layer 1 feature map with the orange dashed border. The layer 2 filter with the green dashed border slides over the layer 1 feature maps and produces the layer 2 feature map with the green dashed border.}
    \label{fig:convolutional_neural_nets:alexnet_feature_maps}
\end{figure}

There are a few things to notice in this figure. First, the spatial resolution of the feature maps get lower as we go deeper into the network, and the number of channels increases. This is common in CNNs: each layer downsamples and adds channels to partially compensate for the reduction in resolution. Second, while on the first layer the feature maps are sensitive to basic patterns in the input image -- edges, lines, etc -- the maps become more abstracted as we go deeper. This is typical of image classifier networks: channels in the shallow layers capture basic image features and channels in the deeper layers increasingly correspond to class semantics (e.g., one channel might be a heatmap of where the ``bird'' pixels are).

\Fig{\ref{fig:convolutional_neural_nets:feature_maps_pca_viz}} shows one more way to visualize feature maps. Rather than plotting the channels as a column of grayscale images, we run PCA to reduce the channel dimensionality to 3. Then we can directly render each feature map as a color image, with red showing the first priniciple component of each layer's feature map, green the second, and blue the third. We show this for 5 layers in three common networks, AlexNet, VGG16~\cite{vgg16}, and ResNet18~\cite{he2016deep}.

\begin{figure}[h]
    \centerline{
        \includegraphics[width=1.0\linewidth]{figures/convolutional_neural_nets/feature_maps_pca_viz.pdf}
    }
    \caption{PCA visualization of feature maps in three convolutional networks. Because each of these networks has a different number of layers, we select 5 that are evenly spaced from the first to last convolutional feature map.}
    \label{fig:convolutional_neural_nets:feature_maps_pca_viz}
\end{figure}


\section{Receptive Fields}\label{sec:convolutional_neural_nets:receptive_fields}

\index{Receptive fields}\textbf{Receptive fields} are another important concept when working with CNNs. In \chap{\ref{chap:challenge_of_vision}}, we learned about history of receptive fields in neuroscience. As a reminder, the receptive field of a neuron is the region of the input signal that the neuron is sensitive to, i.e. its support. In multilayer perceptrons (MLPs, \chap{\ref{chapter:neural_nets}}), the receptive field of each neuron is the entire input vector since MLPs use \textit{fully} connected layers. In CNNs, on the other hand, each neuron only sees a portion of the input, since each output neuron on a conv layer is only connected to a subset of inputs to the conv layer, determined by the kernel size of the filter that produces that output.

The receptive fields of two example neurons in a CNN are shown below (\fig{\ref{fig:convolutional_neural_networks:RFs}}):
\begin{figure}[h!]
    \centerline{
        \begin{minipage}{0.49\linewidth}
            \centerline{
                \begin{tikzpicture}
                    \begin{scope}[rotate=-90]
                        %
                        \def\Nnodes{7}
                        \def\Nlayers{4}
                        \def\layerheight{1.2}
                        \def\neuronrad{0.1}
                        \def\neuronstep{0.3}
                        % draw all nodes
                        \foreach \y in {1,...,\Nlayers} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \draw [fill=white] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                                    }
                            }
                        % draw nodes in RF
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${x_2[3]}$] (myNode) at (\neuronstep*4,\layerheight*3) {};
                        %
                        \foreach \x in {3,...,5} {
                                \draw [fill=black] (\neuronstep*\x,\layerheight*2) circle (\neuronrad);
                            }
                        %
                        \foreach \x in {3,...,5} {
                                \draw [fill=black] (\neuronstep*\x,\layerheight) circle (\neuronrad);
                            }
                        %
                        \foreach \x in {2,...,6} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        % draw all edges
                        \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                        \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                        \foreach \y in {1,...,\NlayersMinusOne} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \foreach \k in {-1,...,1} {
                                                \pgfmathtruncatemacro{\isodd}{mod(\y,2)}
                                                \ifnum\isodd=1
                                                    \foreach \k in {-1,...,1} {
                                                            \pgfmathtruncatemacro{\xk}{\x+\k}
                                                            \ifnum \xk>0
                                                                \ifnum \xk<\NNodesPlusOne
                                                                    \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                                                \fi
                                                            \fi
                                                        }
                                                \else
                                                    \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\x,\layerheight*\y-\neuronrad);
                                                \fi
                                            }
                                    }
                            }
                        % draw edges in RF
                        \foreach \k in {-1,...,1} {
                                \pgfmathtruncatemacro{\xk}{4+\k}
                                \draw [thick] [nn_edge] (\neuronstep*\xk,\layerheight*3+\neuronrad-\layerheight) -- (\neuronstep*4,\layerheight*3-\neuronrad);
                            }
                        \foreach \k in {-1,...,1} {
                                \pgfmathtruncatemacro{\xk}{4+\k}
                                \draw [thick] [nn_edge] (\neuronstep*\xk,\layerheight*2+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*2-\neuronrad);
                            }
                        \foreach \kk in {-1,...,1} {
                                \foreach \k in {-1,...,1} {
                                        \pgfmathtruncatemacro{\xkk}{4+\k+\kk}
                                        \pgfmathtruncatemacro{\xk}{4+\k}
                                        \draw [thick] [nn_edge] (\neuronstep*\xkk,\layerheight+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight-\neuronrad);
                                    }
                            }
                        % draw layer labels
                        \draw (-0.2,\layerheight*0.5) node {\small \texttt{conv}};
                        \draw (-0.2,\layerheight*1.5) node {\small \texttt{relu}};
                        \draw (-0.2,\layerheight*2.5) node {\small \texttt{conv}};
                    \end{scope}
                \end{tikzpicture}
            }
        \end{minipage}
        \begin{minipage}{0.49\linewidth}
            \centerline{
                \begin{tikzpicture}
                    \begin{scope}[rotate=-90]
                        %
                        \def\Nnodes{7}
                        \def\Nlayers{4}
                        \def\layerheight{1.2}
                        \def\neuronrad{0.1}
                        \def\neuronstep{0.3}
                        % draw all edges
                        \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                        \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                        \foreach \y in {1,...,\NlayersMinusOne} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \foreach \k in {-1,...,1} {
                                                \pgfmathtruncatemacro{\isodd}{mod(\y,2)}
                                                \ifnum\isodd=1
                                                    \foreach \k in {-1,...,1} {
                                                            \pgfmathtruncatemacro{\xk}{\x+\k}
                                                            \ifnum \xk>0
                                                                \ifnum \xk<\NNodesPlusOne
                                                                    \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                                                \fi
                                                            \fi
                                                        }
                                                \else
                                                    \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\x,\layerheight*\y-\neuronrad);
                                                \fi
                                            }
                                    }
                            }
                        % draw all nodes
                        \foreach \y in {1,...,\Nlayers} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \draw [fill=white] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                                    }
                            }
                        % draw nodes in RF
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${x_1[5]}$] (myNode) at (\neuronstep*6,\layerheight) {};
                        %
                        \foreach \x in {5,...,7} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        % draw edges in RF
                        \foreach \k in {-1,...,1} {
                                \pgfmathtruncatemacro{\xk}{6+\k}
                                \draw [thick] [nn_edge] (\neuronstep*\xk,\layerheight+\neuronrad-\layerheight) -- (\neuronstep*6,\layerheight-\neuronrad);
                            }
                        % draw layer labels
                        \draw (-0.2,\layerheight*0.5) node {\small \texttt{conv}};
                        \draw (-0.2,\layerheight*1.5) node {\small \texttt{relu}};
                        \draw (-0.2,\layerheight*2.5) node {\small \texttt{conv}};
                    \end{scope}
                \end{tikzpicture}
            }
        \end{minipage}
    }
    \caption{Receptive fields in a CNN. The black filled neurons are within the receptive fields of each labeled neuron (left: ${x_2[3]}$, right: ${x_1[5]}$).}
    \label{fig:convolutional_neural_networks:RFs}
\end{figure}

Notice that the receptive field grows the deeper we go into the network. To understand why, consider a CNN without nonlinearities. Then the $l+1$-th layer is the composition of $l$ convolutional filters. As we saw in \sect{\ref{sec:linear_image_filtering:properties_of_the_convolution}}, composing filters results in a new filter with larger support (kernel size). The same happens in a CNN with pointwise nonlinearities, since pointwise operations do not affect receptive field (the outputs have the same receptive fields as the inputs). Further, whenever we have a downsampling layer by factor $s$, the receptive field of the output is $s$ times larger than the receptive field of the input. Because of these properties, receptive field sizes can grow rapidly as we go deeper in CNNs. Generally we want that the final layer of the CNN has large enough receptive fields to see entire input image, so that output neurons are sensitive to \textit{all} pixels in the input. This can be achieved with a \texttt{gap} layer, whose output will always have a receptive field size that covers the entire input.

\section{Spatial Outputs}\label{sec:convolutional_neural_networks:spatial_outputs}
In \sect{\ref{sec:convolutional_neural_nets:simple_CNN}} we saw a CNN that outputs a single class probability vector for an image. What if we want to output a spatially varying map of predictions, like we discussed in the intro to this chapter? To achieve this, we can simply downsample less, so that the final layer of the CNN is a feature map that maintains higher spatial resolution. It is also important to remove any global pooling layers.

An example is given below:
\begin{align}
    \mathbf{z}_1[c_1,:,:] & = \sum_{c=0}^2 \mathbf{w}_1[c,c_1,:,:] \star \mathbf{x} + b_1[c_1]           & \triangleleft \quad \texttt{conv}                                    \\
                          &                                                                              & [3 \times N \times M] \rightarrow [C_1 \times N \times M]\nonumber   \\
    h[c_1,n,m]            & = \max(z_1[c_1,n,m],0)                                                       & \triangleleft \quad \texttt{relu}                                    \\
                          &                                                                              & [C_1 \times N \times M] \rightarrow [C_1 \times N \times M]\nonumber \\
    \mathbf{z}_2[c_2,:,:] & = \sum_{c_1=0}^{C_1-1} \mathbf{w}_2[c_1,c_2,:,:] \star \mathbf{x} + b_2[c_2] & \triangleleft \quad \texttt{conv}                                    \\
                          &                                                                              & [C_1 \times N \times M] \rightarrow [C_2 \times N \times M]\nonumber \\
    y[k,n,m]              & = \frac{e^{-\tau z_2[k,n,m]}}{\sum_{l=1}^K e^{-\tau z_2[l,n,m]}}             & \triangleleft \quad \texttt{softmax}                                 \\
                          &                                                                              & [K \times N \times M] \rightarrow [K \times N \times M]\nonumber
\end{align}
%\marginnote{All these equations apply for all $i \in \{0,\ldots,C\}$, where $C$ is the number of channels, whatever it may be, on each layer.}[-4cm]

In \fig{\ref{fig:convolutional_neural_networks:image_to_image_arch}} we visualize this CNN (showing only a 1D slice of this 2D CNN):
\marginnote{Notation reminder: nodes that are squares indicate that they represent multiple channels (each is a vector of neurons)}[-1.4cm]
\begin{figure}
    \centerline{
        \begin{tikzpicture}
            \begin{scope}[rotate=-90]
                %
                \def\Nnodes{9}
                \def\Nlayers{5}
                \def\layerheight{1.2}
                \def\neuronrad{0.1}
                \def\neuronstep{0.35}
                % draw input and output images
                \draw (\neuronstep*2.75, -0.25*\layerheight) node[inner sep=0] {\includegraphics[width=0.14\linewidth]{./figures/convolutional_neural_nets/birds_skewed_input.pdf}};
                \draw (\neuronstep*2.75, \layerheight*5.25) node[inner sep=0] {\includegraphics[width=0.14\linewidth]{./figures/convolutional_neural_nets/birds_skewed_output.pdf}};
                % draw all edges
                \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                \foreach \y in {1,...,\NlayersMinusOne} {
                        \foreach \x in {1,...,\Nnodes} {
                                \pgfmathtruncatemacro{\isodd}{mod(\y,2)}
                                \ifnum\isodd=1
                                    \foreach \k in {-1,...,1} {
                                            \pgfmathtruncatemacro{\xk}{\x+\k}
                                            \ifnum \xk>0
                                                \ifnum \xk<\NNodesPlusOne
                                                    \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                                \fi
                                            \fi
                                        }
                                \else
                                    \draw [thin] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\x,\layerheight*\y-\neuronrad);
                                \fi
                            }
                    }
                % draw all nodes
                \foreach \y in {1,...,\Nlayers} {
                        \foreach \x in {1,...,\Nnodes} {
                                %\draw [fill=white] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                                \draw [fill=white] (\neuronstep*\x-\neuronrad,\y*\layerheight-\layerheight-\neuronrad) rectangle ++(\neuronrad*2,\neuronrad*2);
                            }
                    }
                % draw nodes in RF
                %\foreach \x in {5,...,7} {
                %    \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                %}
                % draw edges in RF
                \foreach \k in {-1,...,1} {
                        \pgfmathtruncatemacro{\xk}{2+\k}
                        \draw [thick, color=param_color_dark] [nn_edge] (\neuronstep*\xk,\layerheight+\neuronrad-\layerheight) -- (\neuronstep*2,\layerheight-\neuronrad);
                    }
                \foreach \k in {-1,...,1} {
                        \pgfmathtruncatemacro{\xk}{2+\k}
                        \draw [thick, color=param_color_dark] [nn_edge] (\neuronstep*\xk,\layerheight*3+\neuronrad-\layerheight) -- (\neuronstep*2,\layerheight*3-\neuronrad);
                    }
                %
                % draw layer labels
                \draw (-0.2,\layerheight*0.5) node {\small \texttt{conv}};
                \draw (-0.2,\layerheight*1.5) node {\small \texttt{relu}};
                \draw (-0.2,\layerheight*2.5) node {\small \texttt{conv}};
                \draw (-0.2,\layerheight*3.5) node {\small \texttt{softmax}};
            \end{scope}
        \end{tikzpicture}
    }
    \caption{A 1D slice of a CNN that maps an image to an image. The input is the photo of size $3 \times N \times M$ and the output is a class probability map of size $K \times N \times M$; we visualize the corresponding label map on the right (per-pixel argmax over output probabilities). The blue arrows are the learnable parameters. The gray arrows share the weights of the blue arrows.}
    \label{fig:convolutional_neural_networks:image_to_image_arch}
\end{figure}

Although historically CNNs first became popular as image classifiers, this usage hides their real power. Rather than thinking of them as image-to-label architectures, think of them as \textit{image-to-image} architectures.\marginnote{More generally, CNNs are $\mathcal{X}$-to-$\mathcal{X}$ architectures for any domain $\mathcal{X}$ over which translation can be defined.}[-1cm] %When a CNN is used to predict a single class label for an image, that's just the special case where the output is a 1x1 image. This perspective may become clearer in the following section, where we interpret a CNN as just another kind of image filter.

\section{CNN as a Sliding Filter}

%In the last section we found that a CNN, without downsampling, maps images to images. What about a CNN classifier that downsamples label prediction? As long as there are no global layers (\texttt{gap}, \texttt{fc}), you should still think of this as an image-to-image architecture, just, just the output image is size 1x1. Why is this a useful perspective? We will explain by giving an example:

%Suppose you have a CNN that takes a $256 \times 256$ pixel image as input and downsamples to a 1x1 output, which is the image's predicted class. We will only use strided \texttt{conv} layers in this network, along with pointwise nonlinearities.\marginnote{Such an architecture is sometimes called ``fully convolutional''~\cite{FCNs}.}[0.4cm] Now what happens if we feed this network a $512 \times 512$ resolution input? The output will be a $2 \times 2$ label map! This is because our network downsampled a $256 \times 256$ resolution input to $1 \times 1$, so it downsamples by a factor of 256, so a $512 \times 512$ input will result in a $2 \times 2$ output. Because the network is 

%In \sect{\ref{sec:convolutional_neural_nets:receptive_fields}} we saw that every neuron in a CNN has a receptive field that covers some patch of the input image. This is of course true for the output neurons too, and adjacent output neurons will correspond to adjacent, potentially overlapping, patches of the input. You might have noticed that this kind of mapping -- input patches to output values -- looks a lot like an image filter. It turns out that this interpretation is valid.

%On deep enough layers, this ``patch'' might cover the entire input. However, CNNs also have the property that 

%, but if the input image is large enough, or unbounded, then each output layer neuron will only see a portion of the input.\marginnote{In this section we do not use any global pooling layers or fully-connected layers; we only consider CNNs with convoultional layers and pointwise nonlinearities. Sometimes such nets are called ``fully convolutional''~\cite{FCNs}.}[0.4cm]

The core of CNNs are the convolutional layers, and in this section we will consider a CNN with only \texttt{conv} layers interleaved with pointwise nonlinearities. Such a CNN is sometimes called a \index{Fully convolutional network}\textbf{fully convolutional network} or \textbf{FCN}~\cite{FCNs}. What we will show below is that a whole FCN is just another sliding image filter.

To see why, consider a CNN that processes a 1D signal, and outputs a feature map $\mathbf{x}_L$. Take two feature vectors in the output map, $\mathbf{x}_L[:,i]$ and $\mathbf{x}_L[:,j]$. The feature vector at location $i$ is some function, $F$, of the input patch in its receptive field, $\mathbf{x}_L[:,i] = F(\xin[:,\texttt{RF}(i)])$, where $\texttt{RF}$ returns the coordinates of the receptive field in the input image. It turns out that the feature vector at pixel $j$ is produced by the \textit{same} function, just applied to a different patch of the input: $\mathbf{x}_L[:,j] = F(\xin[:,\texttt{RF}(j)])$.

This is easiest to understand with a visual proof, which we give in \fig{\ref{fig:convolutional_neural_networks:CNN_as_filter}} (pointwise nonlinearities are omitted for clarity):
\begin{figure}[h!]
    \centerline{
        \begin{minipage}{0.49\linewidth}
            \centerline{
                \begin{tikzpicture}
                    \begin{scope}[rotate=-90]
                        %
                        \def\Nnodes{12}
                        \def\Nlayers{3}
                        \def\layerheight{1.2}
                        \def\neuronrad{0.1}
                        \def\neuronstep{0.3}
                        % draw all nodes
                        \foreach \y in {1,...,\Nlayers} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \draw [fill=white] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                                    }
                            }
                        % draw nodes in RF
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${\mathbf{x}_L[i]}$] (myNode) at (\neuronstep*3,\layerheight*2) {};
                        %
                        \foreach \x in {2,...,4} {
                                \draw [fill=black] (\neuronstep*\x,\layerheight) circle (\neuronrad);
                            }
                        \foreach \x in {1,...,5} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        %
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${\mathbf{x}_L[j]}$] (myNode) at (\neuronstep*10,\layerheight*2) {};
                        %
                        \foreach \x in {9,...,11} {
                                \draw [fill=black] (\neuronstep*\x,\layerheight) circle (\neuronrad);
                            }
                        \foreach \x in {8,...,12} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        % draw all edges
                        \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                        \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                        \foreach \y in {1,...,\NlayersMinusOne} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \foreach \k in {-1,...,1} {
                                                \pgfmathtruncatemacro{\xk}{\x+\k}
                                                \ifnum \xk>0
                                                    \ifnum \xk<\NNodesPlusOne
                                                        \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                                    \fi
                                                \fi
                                            }
                                    }
                            }
                        % draw edges in RF
                        \def\colors{{"cyan", "magenta", "orange"}}
                        \foreach \k in {-1,...,1} {
                                \pgfmathtruncatemacro{\xk}{3+\k}
                                \pgfmathparse{\colors[\k+1]}
                                \edef\colorvalue{\pgfmathresult}
                                \draw [ultra thick, color=\colorvalue] [nn_edge] (\neuronstep*\xk,\layerheight*2+\neuronrad-\layerheight) -- (\neuronstep*3,\layerheight*2-\neuronrad);
                            }
                        \def\colors{{"purple", "yellow", "teal"}}
                        \foreach \kk in {-1,...,1} {
                                \pgfmathparse{\colors[\kk+1]}
                                \edef\colorvalue{\pgfmathresult}
                                \foreach \k in {-1,...,1} {
                                        \pgfmathtruncatemacro{\xkk}{3+\k+\kk}
                                        \pgfmathtruncatemacro{\xk}{3+\k}
                                        \draw [ultra thick, color=\colorvalue] [nn_edge] (\neuronstep*\xkk,\layerheight+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight-\neuronrad);
                                    }
                            }
                        %
                        \def\colors{{"cyan", "magenta", "orange"}}
                        \foreach \k in {-1,...,1} {
                                \pgfmathtruncatemacro{\xk}{10+\k}
                                \pgfmathparse{\colors[\k+1]}
                                \edef\colorvalue{\pgfmathresult}
                                \draw [ultra thick, color=\colorvalue] [nn_edge] (\neuronstep*\xk,\layerheight*2+\neuronrad-\layerheight) -- (\neuronstep*10,\layerheight*2-\neuronrad);
                            }
                        \def\colors{{"purple", "yellow", "teal"}}
                        \foreach \kk in {-1,...,1} {
                                \pgfmathparse{\colors[\kk+1]}
                                \edef\colorvalue{\pgfmathresult}
                                \foreach \k in {-1,...,1} {
                                        \pgfmathtruncatemacro{\xkk}{10+\k+\kk}
                                        \pgfmathtruncatemacro{\xk}{10+\k}
                                        \draw [ultra thick, color=\colorvalue] [nn_edge] (\neuronstep*\xkk,\layerheight+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight-\neuronrad);
                                    }
                            }
                    \end{scope}
                \end{tikzpicture}
            }
        \end{minipage}
        \begin{minipage}{0.49\linewidth}
            \centerline{
                \begin{tikzpicture}
                    \begin{scope}[rotate=-90]
                        %
                        \def\Nnodes{12}
                        \def\Nlayers{3}
                        \def\layerheight{1.2}
                        \def\neuronrad{0.1}
                        \def\neuronstep{0.3}
                        % draw all nodes
                        \foreach \y in {1,\Nlayers} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \draw [fill=white] (\neuronstep*\x,\y*\layerheight-\layerheight) circle (\neuronrad);
                                    }
                            }
                        \foreach \x in {1,...,\Nnodes} {
                                \draw [thin, color=gray!33] (\neuronstep*\x,2*\layerheight-\layerheight) circle (\neuronrad);
                            }
                        % draw nodes in RF
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${\mathbf{x}_L[i]}$] (myNode) at (\neuronstep*3,\layerheight*2) {};
                        %
                        \foreach \x in {1,...,5} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        %
                        \node [circle, draw, fill=black, inner sep=\neuronrad*0.7 cm, minimum size=\neuronrad, label=right:${\mathbf{x}_L[j]}$] (myNode) at (\neuronstep*10,\layerheight*2) {};
                        %
                        \foreach \x in {8,...,12} {
                                \draw [fill=black] (\neuronstep*\x,0) circle (\neuronrad);
                            }
                        % draw all edges
                        \pgfmathtruncatemacro{\NlayersMinusOne}{\Nlayers - 1}
                        \pgfmathtruncatemacro{\NNodesPlusOne}{\Nnodes + 1}
                        \foreach \y in {1,...,\NlayersMinusOne} {
                                \foreach \x in {1,...,\Nnodes} {
                                        \foreach \k in {-1,...,1} {
                                                \pgfmathtruncatemacro{\xk}{\x+\k}
                                                \ifnum \xk>0
                                                    \ifnum \xk<\NNodesPlusOne
                                                        \draw [thin, color=gray!33] [nn_edge] (\neuronstep*\x,\layerheight*\y+\neuronrad-\layerheight) -- (\neuronstep*\xk,\layerheight*\y-\neuronrad);
                                                    \fi
                                                \fi
                                            }
                                    }
                            }
                        % draw edges in RF
                        \draw [thick, fill=gray!33, opacity=0.5] (\neuronstep*1-0.1,\neuronrad+0.1) -- (\neuronstep*3-0.1,\layerheight*2-\neuronrad-0.1) -- (\neuronstep*3+0.1,\layerheight*2-\neuronrad-0.1) -- (\neuronstep*5+0.1,\neuronrad+0.1) -- cycle;
                        \node at (\neuronstep*3,\layerheight) {$F$};
                        %
                        \draw [thick, fill=gray!33, opacity=0.5] (\neuronstep*8-0.1,\neuronrad+0.1) -- (\neuronstep*10-0.1,\layerheight*2-\neuronrad-0.1) -- (\neuronstep*10+0.1,\layerheight*2-\neuronrad-0.1) -- (\neuronstep*12+0.1,\neuronrad+0.1) -- cycle;
                        \node at (\neuronstep*10,\layerheight) {$F$};
                    \end{scope}
                \end{tikzpicture}
            }
        \end{minipage}
    }
    \caption{A CNN is a non-linear filter. Edge colors indicate shared weights; two edges with the same color have the same weight. The colors demonstrate that the same function $F$ is applied to each patch of input nodes.}
    \label{fig:convolutional_neural_networks:CNN_as_filter}
\end{figure}

%\marginnote{\Fig{\ref{fig:convolutional_neural_nets:CNN_example_fine}} shows this process for a 2D image where the CNN predicts the label of the center pixel of each overlapping patch of the input, thereby solving the problem of semantic segmentation.}[-0.4cm]

To understand this property, first imagine the CNN has no pointwise nonlinearities. Then the entire CNN is just the composition of a sequence of convolutions, which itself is a convolution (by \eqn{\ref{eqn:linear_image_filtering:conv_associative_property}}, convolving a signal with multiple filters in a row is equivalent to convolving the signal with a single equivalent filter). Therefore, a CNN with no nonlinearities is itself just a single big convolutional filter. The key property of such a system is that it processes each input patch independently and identically. Now notice that this key property is unchanged when we add pointwise nonlinearities, because they introduce no interaction between neurons or pixels (they are pointwise after all). Hence it follows that a complete CNN, made up only of convolutional layers and pointwies nonlinearities, is itself a nonlinear operator that applies the same transformation independently and identically to each patch of the input signal, i.e. a nonlinear filter!\marginnote{This is why, in the intro to this chapter, we visualized a CNN as chopping up an image into patches and applying the same ``classifier'' function to each patch.}[-2.2cm]

%Now that we have understood a CNN as a filter, we can borrow all our intuitions about image filtering. If the input to a CNN is an image, the output is an image, if the input is a 3D volume, the output is a 3D volume, and so forth. Filters map signals to signals with the same topology. In computer vision, \textit{the role of the CNN is to be an image-to-image architecture}. When a CNN is used as an image classifier, this is best thought of as the special case where the output ``image'' is just 1 pixel big, and that pixel has a single label.

%We can now see how to immediately turn a classifier CNN into a semantic segmentation architecture. Just slide it across the image.

%Each application of $f$ here is a mapping from a bigger input region to a smaller output region, and this is because of how receptive field size grows layer by layer. When we supervise such a system, should the label of this patch be bird or sky? A good strategy is to set the label of the patch to be the category of the central pixel in the patch. This way each application of $f$ is solving the problem ``what is the category of the center pixel of this patch'' and when we slide $f$ densely it outputs a high resolution image.

\section{Why Process Images Patch by Patch?}\label{sec:convolutional_neural_nets:key_properties}

As we have seen above, a fully convoutional CNN can be thought of a function that processes each patch of the input independently and identically. \marginnote{Although some CNNs have non-convolutional layers, like \texttt{gap} and \texttt{fc} layers, what defines CNNs is the stack of fully convolutional layers, i.e. the convolutions and pointwise activations.}[-1.05cm]%\marginnote{Note that pointwise nonlinearities are sliding nonlinear filters with kernel size 1}

%, CNNs have two important properties: 1) each patch is processed independently from all the others, and 2) each patch is processed identically. We will next describe why each property is useful.

In this section we will discuss why these two propties are useful for image processing.

\paragraph*{Property \#1: Treating Patches as Independent}
This is a divide-and-conquer strategy. If you were to try to understand a complex problem, you might break it up into small pieces and solve each one separately. That's all a CNN is doing. We split up a big problem (i.e. ``interpret this whole photo'') into a bunch of smaller problems (i.e. ``interpret each small patch in the image'').

Why is this a good strategy?
\begin{enumerate}
    \item The small problems are easier to solve than the original problem.
    \item The small problems can all be solved in parallel.
    \item This approach is \textit{agnostic to signal length}, that is, you can solve an arbitrarily large problem just by breaking it down to bite size pieces and solving them ``bird by bird''~\cite{lamott1980}.
\end{enumerate}

Chopping up into small patches like this is sufficient for many vision problems because the world exhibits {\bf locality}: related things clump together, that is, within a single patch; far apart things can often be safely assumed to be independent.


\paragraph*{Property \#2: Processing Each Patch Identically}
For images, convolution is an especially suitable strategy because visual content tends to be \textit{translation invariant}, and, as we learned in previous chapters, the convolution operator is also translation invariant.

Typically, objects can appear anywhere in an image and look the same, like the birds in the photo from \fig{\ref{fig:convolutional_neural_nets:CNNs_as_patch_processing}}. This is because as the birds fly across the frame their position changes but their identity and appearance does not. More generally, as a camera pans across a scene, the content shifts in position but is otherwise unchanged.

Because the visual world is roughly translation invariant, it is justified to process each patch the same way, regardless of its position (i.e., its translation away from some canonical center patch).

\index{Translation invariance}\textbf{Translation invariant} just means we process each patch identically, using the same function $f$. Some texts instead use the term \index{Translation equivariance}{\bf translation equivariant} to describe convolutions. This places emphasis on the fact that if we shift the input signal by some translation, then the output signal will get shifted by the same amount. That is, if $f$ is a convolution, we have the property:
\begin{align}
    f(\texttt{translate}(\mathbf{x})) = \texttt{translate}(f(\mathbf{x}))
\end{align}



\section{Popular CNN Architectures}
\label{sec:convolutional_neural_nets:popular_architectures}
We have now seen all the essential building blocks of CNNs. In this section we will treat these blocks like LEGOs and show how to piece them together to make a variety of useful architectures.

\subsection{Encoder and Decoders}
In \chap{\ref{chapter:image_pyramids}}, we encountered image pyramids that include both an analysis pipeline, which converts an image into a multiscale representation of filter responses, and a synthesis pipeline, which reconstructs the image from the filter responses. Deep networks also may operate in either the analysis direction or the synthesis direction. In the context of deep networks, we call the analysis network an \textbf{encoder} and the synthesis network a \textbf{decoder}. An encoder maps from data to a representation of that data, which is usually lower dimensional, and a decoder performs the inverse operation, mapping from a representation back to the data. %In the image processing chapters we used the terms ``analysis" for encoding and ``synthesis" for decoding; in the context of neural nets, ``encoder" and ``decoder" are the more common terms but the meaning is the same.

Encoder and decoder networks will appear many times in this book, and can be made from many different architectures, including those that are not neural nets. In the context of CNNs, encoders are typically nets that take an image as input and then downsample it, layer by layer, until producing a much lower-dimensional feature map as output. A decoder is the opposite, taking a set of low-dimensional features as input, then upsampling them, layer by layer, until producing an image as the final output. An example of an encoder is an image classifier and an example of a decoder is an image generator (covered in \chap{\ref{chapter:generative_models}}). These two architectural patterns are shown in \fig{\ref{fig:convolutional_neural_nets:encoders_and_decoders}}.
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.75\linewidth]{./figures/convolutional_neural_nets/encoders_and_decoders.pdf}
    }
    \caption{A convolutional encoder (top) and a convolutional decoder (bottom). The exact ordering of the operations (e.g., downsample before or after the non-linearity) is just an example and may vary in different encoder and decoder models. The $\mathbf{z}$ is a feature map or vector of neural activations, and is sometimes called an \textbf{embedding} (see \chap{\ref{chapter:representation_learning}}).}
    \label{fig:convolutional_neural_nets:encoders_and_decoders}
\end{figure}

One powerful thing you can do with encoders and decoders is to put them together, forming an \index{Encoder-decoder}\textbf{encoder-decoder}. Such an architecture first encodes the input image into a low-dimensional representation, then decodes the representation back into an image output. This is therefore a suitable architecture for image-to-image problems, and it has a few advantages over the image-to-image CNNs we saw in \sect{\ref{sec:convolutional_neural_networks:spatial_outputs}}: 1) by downsampling, the internal feature maps are smaller, using less memory and computation, 2) encoder-decoders introduce an \index{Information bottleneck}\textbf{information bottleneck} -- i.e. the representation between the encoder and decoder is low-dimensional and can only transmit so much information -- and this forces abstraction. This latter concept is one we will study in much greater detail in \chap{\ref{chapter:representation_learning}}, where we will see several benefits of compressing a signal. A schematic of the encoder-decoder architecture is shown in \fig{\ref{fig:convolutional_neural_nets:encoder_decoders}}.
\begin{figure}[h]
    \centerline{
        \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/encoder_decoder_arch.pdf}
    }
    \caption{Encoder-decoder architecture. In this example, the input is an image and the output is a segmentation map.}
    \label{fig:convolutional_neural_nets:encoder_decoders}
\end{figure}

\subsection{U-Nets}\label{sec:convolutional_neural_nets:unet}
\index{U-Net}
Encoder-decoders force the signal to pass through a bottleneck, and although this can be a good thing (as discussed above), it also makes the task of the decoder rather difficult. In particular, the decoder may fail to be able to output high frequency details; for a semantic segmentation network, the consequence could be that the predicted label map is very coarse.

%an {\bf information bottleneck}: the encoder maps a high-dimensional signal to a low-dimensional encoding, which has limited capacity to store information, and the decoder must somehow reconstruct a high-dimensional output from the encoding. Although this can be a very efficient way to process data it also can cause the net to fail to be able to output high frequency details, so, e.g., a predicted label map might be very coarse.

To circumvent this problem, we can add \index{Skip connections}{\bf skip connections} that shuttle information directly across blocks of layers in the net. A skip connection $f$ is simply an identity pathway that connects two disparate layers of a net, $f(\mathbf{x}) = \mathbf{x}$.
%Two common choices are concatenating the output with the activations on the later layer, or adding the outputs.

Adding skip connections to an encoder-decoder results in an architecture known as a {\bf U-Net}~\cite{ronneberger2015u}. In this architecture, skip connections are arranged in a mirror pattern, where layer $l$ is connected directly to layer $(L-l)$. The output of a skip connection must somehow be reintegrated into the network. U-nets do this by concatenating the activations from the prior layer to the activations on the later layer, along the channel dimension. This architecture can maintain the information-bottleneck of the encoder-decoder, with its incumbent benefits in terms of memory and compute efficiency and forced abstraction, while also allowing residual information to flow through the skip connections, thereby not sacrificing the ability to output high-frequency spatial predictions. U-Nets look a lot like the steerable pyramids from \chap{\ref{chapter:image_pyramids}}, which also consistent of a downsampling \textit{analysis} path followed by an upsampling \textit{synthesis} path, with skip connections in between mirror image stages in the pathways. The main difference is that the U-Net has \textit{learned filters} and \textit{nonlinearities}. A schematic of a U-net is given in \fig{\ref{fig:convolutional_neural_nets:unet}}.
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.85\linewidth]{./figures/convolutional_neural_nets/unet.pdf}
    }
    \caption{U-net architecture. Each block contains a series of layers. The skip connections concatenate activations.}
    \label{fig:convolutional_neural_nets:unet}
\end{figure}

\subsection{ResNets}
\index{ResNet}
Another popular architecture that uses skip connections is called {\bf Residual Networks} or {\bf ResNets}~\cite{he2016deep}.\marginnote{See also Highway Networks~\cite{srivastava2015highway}, a related architecture that uses a form of skip connection but controlled by multiplicative gates.}[-0.4cm]
In the context of ResNets, skip connections are called \index{Residual connections}{\bf residual connections}. This kind of skip connection is \textit{added} to the output of a block of layers $F$:
\begin{align}
    \xout = F(\xin) + \xin \quad\quad \triangleleft \quad \texttt{residual block}
\end{align}
In a {\bf residual block} like this, you can think of $F$ as a \textit{residual} that additively perturbs $\xin$ to transform it into an improved $\xout$. If $\xout$ does not have the same dimensionality as $\xin$, then we can add a linear mapping to convert the dimensions: $\xout = F(\xin) + \mathbf{W}\xin$.

It is easy for a residual block to simply perform an identity mapping, it just has to learn to set $F$ to zero. Because of this, if we stack many residual blocks in a row, it can end up that the net learns to use only a subset of them. If we set the number of stacked residual blocks to be very large then the net can essentially learn how deep to make itself, using as many blocks as necessary to solve the task. ResNets often exploit this fact by being very deep; for example, they may be hundreds of blocks deep. \Fig{\ref{fig:convolutional_neural_nets:resnet}} depicts a 5 block deep ResNet.
\begin{figure}[h]
    \centerline{
        \includegraphics[width=0.85\linewidth]{./figures/convolutional_neural_nets/resnet.pdf}
    }
    \caption{ResNet architecture. Each block contains a series of layers. The skip connections add activations from one block to the next.}
    \label{fig:convolutional_neural_nets:resnet}
\end{figure}


%\section{Encoder and decoders}
%An {\bf encoder} maps from data to a representation of that data, which is usually lower dimensional. A {\bf decoder} performs the inverse operation, mapping from the representation back to the data. In the image processing chapters we used the terms ``analysis" for encoding and ``synthesis" for decoding; in the context of neural nets, ``encoder" and ``decoder" are the more common terms but the meaning is the same.

%A common architecture for an encoder is a sequence of conv layers that downsample. This is a way to reduce dimensionality. Decoders are the mirror image: they may be a sequence of conv layers that upsample. The result looks like this:
% \begin{figure}[h]
%     \centerline{
%     \includegraphics[width=1\linewidth]{./figures/convolutional_neural_nets/encoder_decoder_arch.pdf}
%     }
%     \caption{Encoder-decoder architecture. In this example, the input is an image and the output is a segmentation map.}
% \end{figure}

%\marginnote{More generally, this architecture is useful for image-in, image-out problems, also called image-to-image problems, where the input and output are both shaped liked images.}[-0.4cm]


%\subsection{Skip connections}




%U-Nets
%ResNets
%DenseNets



% \section{CNNs as patch processing}
% As mentioned at the start of this chapter, one way to think about convolutional layers is that they are \textit{patch processing}: an input signal is cut up into chunks and then each chunk is processed independently and identically. To see this, we can rewrite Eqn. \ref{eqn:convolutional_neural_nets:convolutional_filter} as a chopping up and processing algorithm:
% \begin{algorithm}[h]
% \caption{Convolution layer}
% \label{alg:convolutional_neural_nets:conv_as_patch_processing}
% \SetAlgoVlined
% \DontPrintSemicolon
% {\bf Input:} $\textcolor{data_color}{\xin} \in \mathbb{R}^{M \times N}$, $\textcolor{param_color}{\mathbf{w}} \in \mathbb{R}^{2p+1 \times 2p+1}$, $\textcolor{param_color}{b} \in \mathbb{R}$, 
% {\bf Output:} $\textcolor{data_color}{\xout} \in \mathbb{R}^{M \times N}$\;
% \For{\upshape $i = 1, \dots, M$} {
% \For{\upshape $j = 1, \dots, N$}
% {
%     $\mathbf{\xinpatch}[i*N+j] = \textcolor{data_color}{\xin}[i-p:i+p, j-p:j+p]\quad\triangleleft \text{Chop up image into patches}$\;
% }
% }
% \For{\upshape $i = 1, \dots, MN$} {
%     $\mathbf{\xoutpatch}[i] = \textcolor{param_color}{\mathbf{w}}^T\mathbf{\xinpatch}[i] + \textcolor{param_color}{b} \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\triangleleft \text{Process patches}$\;
% }
% \For{\upshape $i = 1, \dots, MN$} {
%     $k = \texttt{floor}(i/N)$,
%     $l = i - kN$\;
%     $\textcolor{data_color}{\xout}[k-p:k+p,l-p:l+p] = \mathbf{\xoutpatch}[i] \quad\quad\quad\quad\triangleleft \text{Recombine patches into image}$\;
% }
% \label{alg:convoultional_neural_nets:conv_layer_as_patch_processing}
% \end{algorithm}
% % \begin{align}
% %     \mathbf{x}_{\texttt{in_patch}} = \xin[m_1:m_2, n_1,n_2]
% %     \mathbf{x}_{\texttt{out_patch}}
% % \end{align}

% Note that padding must be applied for the values that extend outside the image boundaries. \textit{Exercise}: convince yourself of the equivalence between this algorithm and Eqn. \ref{eqn:convolutional_neural_nets:convolutional_filter}.

% So far we have demonstrated that a \textit{convolution layer} is equivalent to parallel patch processing. What about an entire \textit{CNN}? It turns out a full CNN can also be rewritten as chopping up and processing each patch with the same sub-function, but this sub-function is not just an affine transformation -- instead it is a neural net.

% Suppose we have a CNN, which we define as a stack of conv layers, potentially with pointwise nonlinearities in between. By Alg. 1 %\ref{alg:convoultional_neural_nets:conv_layer_as_patch_processing}
% , the final conv layer in the stack can be rewritten as breaking its inputs into patches and processing them with an affine transformation. Each patch of $\xin$ for this layer is an array of neural activations output from the previous layer. Now we can trace back to see which activations input to layer $l-2$ contribute to the activations intput to layer $l-1$ in a given patch. If layer $l-2$ is pointwise, then it will be the same patch on layer $l-2$. If layer $l-2$ is convolutional, then it the receptive field will grow by a factor related to the kernel size, padding, stride, and dilation of that layer. Now we can see that the mapping from layer $l-2$ to $l$ is equivalent to chopping up layer $l-2$ activations into patches (slightly bigger than the patches before) and processing each with a two-layer CNN. Repeating this logic, we can see that the whole CNN is equivalent to chopping up the input into patches at some size and with some overlap, and then running an identical function $f$ on each patch.

%Here is what that looks like:


%The code above chops up the image into densely overlapping patches, each one offset from the last by a single pixel. Instead, we could chop the image up into non-overlapping patches, or into partially overlapping patches. This operation is called {\bf strided convolutions}, and is equivalent to convolution followed by subsampling. Strided convolution maps from $\mathbb{R}^{M \times N \times \ldots} \rightarrow \mathbb{R}^{M/k \times N/k \times \ldots}$, where $k$ is the {\bf stride}. We could also use a different stride in each dimension -- $\mathbb{R}^{M \times N \times \ldots} \rightarrow \mathbb{R}^{M/k_1 \times N/k_2 \times \ldots}$ -- but this is somewhat uncommon.
% add floor notation

%For example, to process the image below, we could first cut it up into patches of size $32 \times 32$ pixels, and then try to recognize what's going on in each patch, running a classifier on each patch:

%If we arrange the classifier predictions back into a 2D array, aligned with the input, then the input-output mapping is a function that maps a 2D image $\in \mathbb{R}^{M \times N}$ to a 2D output array $\in \mathbb{R}^{M/32 \times N/32}$ of predictions:
%\begin{figure}[h]
%    \centering
%    \includegraphics[width=0.85\linewidth]{./figures/convolutional_neural_nets/CNN_example_coarse.pdf}
%    \label{fig:convolutional_neural_nets:CNN_example_coarse}
%\end{figure}

%CNNs can be applied not just to 2D images but to any ND signal. In general, CNNs are mappings from a tensor input to a tensor output with the same shape, except potentially downsampled: $\mathbb{R}^{M \times N \times \ldots} \rightarrow \mathbb{R}^{M^{\prime} \times N^{\prime} \times \ldots}$. If the input is an image, like in the example below, then the output is a 2D array of label predictions; you can think of it as another image, which we can visualize by assigning a color to each predicted label:

%This array of predictions is rather coarse. We can make it finer by chopping up the input image into \textit{overlapping} patches, each set one pixel apart, yielding the following output image:
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.85\linewidth]{./figures/convolutional_neural_nets/CNN_example_fine.pdf}
%     \label{fig:convolutional_neural_nets:CNN_example_fine}
% \end{figure}
% Now that looks impressive! One reason CNNs are powerful is because they output structured representations -- in this case images -- rather than outputting a single label like in the nets we saw in previous chapters.




%\section{Equivalence between CNNs and patch processing}
%In this section we will demonstrate that a CNN, as defined above, is equivalent to first chopping up the input into (potentially overlapping) patches, then applying the same fixed function to all patches.

%If the classifier is a linear function, and we use overlapping patches (each patch is offset one pixel from the last), then this procedure is equivalent to the mathematical definition of discrete convolution. It turns out that the operations in a CNN are also equivalent to this chopping up strategy, even when the classifier applied to each patch is itself a deep net! So you really can think of a CNN as just chopping up the image into overlapping patches and processing each separately. We derive this equivalence in Section XX.
%Let us examine why this description is equivalent to the mathematical definition of convolution.

%So CNNs, and convolution in general, are patch-based signal processors. 

%\section{CNN image pyramids}

%In Chapter XX we saw image pyramids and showed how they can be used for analysis and synthesis. CNNs can also be structured as analysis and synthesis pyramids, and this is a very powerful tool.

%To create a pyramid we just need to introduce a way of downsampling the signal during analysis and upsampling during synthesis. In CNNs this is done with {\bf downsampling and upsampling layers}.


%\section{Semantic Segmentation with a CNN}


%\section{Image classification with a CNN}



%\section{Visualizations of tensors processed by a CNN}

\section{Concluding Remarks}
We will see in later chapters that several new kinds of models are recently supplanting CNNs as the most successful architectures for vision problems. One such architecture is the \textbf{transformer} (\chap{\ref{chapter:transformers}}). It may be tempting to think, ``Why did we bother learning about CNNs then, if transformers are better!'' The reason we cover CNNs is not because the exact architecture presented here will last, but because the underlying principles it embodies are ubiquitous in sensory processing. The two key properties mentioned in \sect{\ref{sec:convolutional_neural_nets:key_properties}} are in fact present in transformers and many other architectures beyond CNNs: transformers also include stages that process each patch identically and independently, but they interleave these stages with other stages that globalize information across patches. It comes down to preferences whether you want to call these newer architectures convolutional or not, and there is currently some debate about it in the community. For us it doesn't matter, because if we learn the principles we can recognize them in all the systems we encounter and need not get hung up on names.

%\section{Historical notes}
%Convnets were introduced by Lecun. Fukushima designed a similar architecture called the %neocognitron.